require "polyvec.jinc"

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_pack_pk
*
* Description: Bit-pack public key pk = (rho, t1).
*
* Arguments:   - uint8_t pk[]: output byte array
*              - const uint8_t rho[]: byte array containing rho
*              - const polyveck *t1: pointer to vector t1
**************************************************/
fn _pack_pk(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[SEEDBYTES] rho, reg ptr u32[polyveck] t1) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] {
    pk = pk; rho = rho; t1 = t1;

    inline int i;

    reg ptr u8[SEEDBYTES] tpk;
    tpk = pk[0:SEEDBYTES];
    tpk = #copy(rho);
    pk[0:SEEDBYTES] = tpk;

    reg ptr u8[POLYT1_PACKEDBYTES] npk;
    reg ptr u32[N] nt1;
    for i = 0 to K {
        nt1 = t1[i * N: N];
        npk = pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES];
        pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES] = _polyt1_pack(npk, nt1);
    }

    return pk;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_pack_sk
*
* Description: Bit-pack secret key sk = (rho, tr, key, t0, s1, s2).
*
* Arguments:   - uint8_t sk[]: output byte array
*              - const uint8_t rho[]: byte array containing rho
*              - const uint8_t tr[]: byte array containing tr
*              - const uint8_t key[]: byte array containing key
*              - const polyveck *t0: pointer to vector t0
*              - const polyvecl *s1: pointer to vector s1
*              - const polyveck *s2: pointer to vector s2
**************************************************/
fn _pack_sk(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk, reg ptr u8[SEEDBYTES] rho, reg ptr u8[SEEDBYTES] tr, reg ptr u8[SEEDBYTES] key, reg ptr u32[polyveck] t0, reg ptr u32[polyvecl] s1, reg ptr u32[polyveck] s2) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] {
    sk = sk; rho = rho; tr = tr; key = key; t0 = t0; s1 = s1; s2 = s2;

    inline int i;
    inline int start_pos;
    start_pos = 0;
    
    reg ptr u8[SEEDBYTES] tsk;
    
    tsk = sk[0:SEEDBYTES];
    tsk = #copy(rho);
    sk[start_pos:SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;
    
    tsk = sk[SEEDBYTES :  SEEDBYTES];
    tsk = #copy(key);
    sk[start_pos : SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;
    
    tsk = sk[2 * SEEDBYTES : SEEDBYTES];
    tsk = #copy(tr);
    sk[start_pos : SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;
    
    reg ptr u8[POLYETA_PACKEDBYTES] nsk;

    () = #spill(t0);
    () = #spill(s2);
    reg ptr u32[N] ns1;
    for i = 0 to L {
        ns1 = s1[i * N: N];
	() = #spill(s1);	
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        sk[start_pos : POLYETA_PACKEDBYTES] = _polyeta_pack(nsk, ns1);
	() = #unspill(s1);
	start_pos += POLYETA_PACKEDBYTES;
    }
    
    () = #unspill(s2);
    reg ptr u32[N] ns2;
    for i = 0 to K {
        ns2 = s2[i * N: N];
	() = #spill(s2);	
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        sk[start_pos : POLYETA_PACKEDBYTES] = _polyeta_pack(nsk, ns2);
        () = #unspill(s2);
	start_pos += POLYETA_PACKEDBYTES;
    }
    () = #unspill(t0);
    
    reg ptr u32[N] nt0;
    reg ptr u8[POLYT0_PACKEDBYTES] nnsk;
    for i = 0 to K {
        nt0 = t0[i * N: N];
        nnsk = sk[start_pos : POLYT0_PACKEDBYTES];
	() = #spill(t0);
        sk[start_pos : POLYT0_PACKEDBYTES] = _polyt0_pack(nnsk, nt0);
	() = #unspill(t0);
	start_pos += POLYT0_PACKEDBYTES;	
    }
    
    return sk;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_pack_sig
*
* Description: Bit-pack signature sig = (c, z, h).
*
* Arguments:   - uint8_t sig[]: output byte array
*              - const uint8_t *c: pointer to PQCLEAN_DILITHIUM5_CLEAN_challenge hash length SEEDBYTES
*              - const polyvecl *z: pointer to vector z
*              - const polyveck *h: pointer to hint vector h
**************************************************/
fn _pack_sig(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, reg ptr u8[SEEDBYTES] c, reg ptr u32[polyvecl] z, reg ptr u32[polyveck] h) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] {
    sig = sig; c = c; z = z; h = h;
    
    inline int i;
    
    inline int start_pos;
    start_pos = 0;
    
    reg ptr u8[SEEDBYTES] ptsig;
    ptsig = sig[0 : SEEDBYTES];
    // FIXME this copy can be improved using 32 bits load and store instead of 8
    ptsig = #copy(c);
    sig[0 : SEEDBYTES] = ptsig;
    start_pos += SEEDBYTES;

    reg ptr u32[N] nz;
    reg ptr u8[POLYZ_PACKEDBYTES] nsig;
    for i = 0 to L {
        nz = z[i * N: N];
        nsig = sig[start_pos : POLYZ_PACKEDBYTES];
        sig[start_pos : POLYZ_PACKEDBYTES] = _polyz_pack(nsig, nz);
	start_pos += POLYZ_PACKEDBYTES;
    }

    reg u32 r0;
    r0 = 0;
    reg ptr u8[OMEGA + K]  pptsig;    
    pptsig = sig[start_pos : OMEGA + K];
    // FIXME use a while loop ?
    // FIXME use 32 bits 0 ? OMEGA + K = 75 + 8 = 83 = 20 * 4 + 3
    for i = 0 to OMEGA + K {
        pptsig[i] = r0;
    }
    
    reg u32 j;
    reg u32 hj;
    reg u32 k;
    k = 0;

    reg ptr u32[N] nh;    
    for i = 0 to K {
       nh = h[i * N: N];
       j = 0;
       while (j < N) {
         hj = nh[j];
         if hj != 0 {
           pptsig[k] = j;
           k += 1;
         }
	 j += 1;
       }
       pptsig[i + OMEGA] = k;
    }
    sig[start_pos : OMEGA + K] = pptsig;
    
    return sig; 
}

// Same as _pack_sig(sig, sig[0:SEEDBYTES], z, h)
fn _pack_sig_nocopy(reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig, reg ptr u32[polyvecl] z, reg ptr u32[polyveck] h) -> reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] {
    sig = sig; z = z; h = h;
    
    inline int i;
    
    inline int start_pos;
    start_pos = 0;
    
    start_pos += SEEDBYTES;

    reg ptr u32[N] nz;
    reg ptr u8[POLYZ_PACKEDBYTES] nsig;
    for i = 0 to L {
        nz = z[i * N: N];
        nsig = sig[start_pos : POLYZ_PACKEDBYTES];
        sig[start_pos : POLYZ_PACKEDBYTES] = _polyz_pack(nsig, nz);
	start_pos += POLYZ_PACKEDBYTES;
    }

    reg u32 r0;
    r0 = 0;
    reg ptr u8[OMEGA + K]  pptsig;    
    pptsig = sig[start_pos : OMEGA + K];
    // FIXME use a while loop ?
    // FIXME use 32 bits 0 ? OMEGA + K = 75 + 8 = 83 = 20 * 4 + 3
    for i = 0 to OMEGA + K {
        pptsig[i] = r0;
    }
    
    reg u32 j;
    reg u32 hj;
    reg u32 k;
    k = 0;

    reg ptr u32[N] nh;    
    for i = 0 to K {
       nh = h[i * N: N];
       j = 0;
       while (j < N) {
         hj = nh[j];
         if hj != 0 {
           pptsig[k] = j;
           k += 1;
         }
	 j += 1;
       }
       pptsig[i + OMEGA] = k;
    }
    sig[start_pos : OMEGA + K] = pptsig;
    
    return sig; 
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_unpack_pk
*
* Description: Unpack public key pk = (rho, t1).
*
* Arguments:   - const uint8_t rho[]: output byte array for rho
*              - const polyveck *t1: pointer to output vector t1
*              - uint8_t pk[]: byte array containing bit-packed pk
**************************************************/
fn _unpack_pk(reg ptr u8[SEEDBYTES] rho, reg ptr u32[polyveck] t1, reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_PUBLICKEYBYTES] pk) -> reg ptr u8[SEEDBYTES], reg ptr u32[polyveck] {
    pk = pk; rho = rho; t1 = t1;
    
    inline int i;

    reg ptr u8[SEEDBYTES] tpk;
    tpk = pk[0 : SEEDBYTES];
    rho = #copy(tpk);
    
    reg ptr u8[POLYT1_PACKEDBYTES] npk;
    reg ptr u32[N] nt1;
    for i = 0 to K {
        nt1 = t1[i * N: N];
        npk = pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES];    
        t1[i * N : N] = _polyt1_unpack(nt1, npk);
    }
    
    return rho, t1;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_unpack_sk
*
* Description: Unpack secret key sk = (rho, tr, key, t0, s1, s2).
*
* Arguments:   - const uint8_t rho[]: output byte array for rho
*              - const uint8_t tr[]: output byte array for tr
*              - const uint8_t key[]: output byte array for key
*              - const polyveck *t0: pointer to output vector t0
*              - const polyvecl *s1: pointer to output vector s1
*              - const polyveck *s2: pointer to output vector s2
*              - uint8_t sk[]: byte array containing bit-packed sk
**************************************************/
fn _unpack_sk
  (reg ptr u8[SEEDBYTES] rho, 
   reg ptr u8[SEEDBYTES] tr, 
   reg ptr u8[SEEDBYTES] key, 
   reg ptr u32[polyveck] t0, 
   reg ptr u32[polyvecl] s1, 
   reg ptr u32[polyveck] s2, 
   reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_SECRETKEYBYTES] sk) 
  -> reg ptr u8[SEEDBYTES], reg ptr u8[SEEDBYTES], reg ptr u8[SEEDBYTES], 
     reg ptr u32[polyveck], reg ptr u32[polyvecl], reg ptr u32[polyveck] 
     // rho, tr, key, t0, s1, s2
{
    sk = sk; rho = rho; tr = tr; key = key; t0 = t0; s1 = s1; s2 = s2;

    inline int i;
    inline int start_pos;
    start_pos = 0;
    
    reg ptr u8[SEEDBYTES] tsk;
    
    tsk = sk[0:SEEDBYTES];
    rho = #copy(tsk);
    start_pos += SEEDBYTES;
    
    tsk = sk[SEEDBYTES :  SEEDBYTES];
    key = #copy(tsk);
    start_pos += SEEDBYTES;
    
    tsk = sk[start_pos : SEEDBYTES];
    tr = #copy(tsk);
    start_pos += SEEDBYTES;
    
    reg ptr u8[POLYETA_PACKEDBYTES] nsk;

    () = #spill(t0);
    () = #spill(s2);
    () = #spill(rho);
    () = #spill(tr);
    () = #spill(key);    
    reg ptr u32[N] ns1;
    for i = 0 to L {
        ns1 = s1[i * N: N];
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        s1[i * N: N] = _polyeta_unpack(ns1, nsk);
	start_pos += POLYETA_PACKEDBYTES;
    }
    
    () = #unspill(s2);
    reg ptr u32[N] ns2;
    for i = 0 to K {
        ns2 = s2[i * N: N];
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
	() = #spill(sk);
        s2[i * N: N] = _polyeta_unpack(ns2, nsk);
        () = #unspill(sk);
	start_pos += POLYETA_PACKEDBYTES;
    }
    () = #unspill(t0);
    () = #spill(s1, s2);
    
    reg ptr u32[N] nt0;
    reg ptr u8[POLYT0_PACKEDBYTES] nnsk;
    for i = 0 to K {
        nt0 = t0[i * N: N];
        nnsk = sk[start_pos : POLYT0_PACKEDBYTES];
        t0[i * N: N] = _polyt0_unpack(nt0, nnsk);
	start_pos += POLYT0_PACKEDBYTES;	
    }
    () = #unspill(rho);
    () = #unspill(tr);
    () = #unspill(key);    
    () = #unspill(s1,s2);
    return rho, tr, key, t0, s1, s2;
}

/*************************************************
* Name:        PQCLEAN_DILITHIUM5_CLEAN_unpack_sig
*
* Description: Unpack signature sig = (c, z, h).
*
* Arguments:   - uint8_t *c: pointer to output PQCLEAN_DILITHIUM5_CLEAN_challenge hash
*              - polyvecl *z: pointer to output vector z
*              - polyveck *h: pointer to output hint vector h
*              - const uint8_t sig[]: byte array containing
*                bit-packed signature
*
* Returns 1 in case of malformed signature; otherwise 0.
**************************************************/
fn _unpack_sig(reg ptr u8[SEEDBYTES] c, 
               reg ptr u32[polyvecl] z, 
               reg ptr u32[polyveck] h, 
               reg ptr u8[PQCLEAN_DILITHIUM5_CLEAN_CRYPTO_BYTES] sig) -> 
         reg ptr u8[SEEDBYTES], reg ptr u32[polyvecl], reg ptr u32[polyveck], reg u32 {
    // fixme this should be in the export function not here
    sig = sig; c = c; z = z; h = h;

    reg u32 status, r0, r1, j, sj, sjm1, sroi, k;
    inline int i;
    inline int start_pos;
    reg ptr u8[SEEDBYTES] ptsig;
    reg ptr u8[OMEGA + K] pptsig;
    reg ptr u32[N] nh, nz;
    reg ptr u8[POLYZ_PACKEDBYTES] nsig;

    ptsig = sig[0 : SEEDBYTES];
    c = #copy(ptsig);
    start_pos = SEEDBYTES;

    () = #spill(c, h);

    for i = 0 to L {
        nz = z[i * N: N];
        nsig = sig[start_pos : POLYZ_PACKEDBYTES];
        z[i * N: N] = _polyz_unpack(nz, nsig);
	start_pos += POLYZ_PACKEDBYTES;
    }

    () = #unspill(c, h);
    status = 0;
    r0 = 0;
    r1 = 1;
    pptsig = sig[start_pos : OMEGA + K];
    k = 0;    
    for i = 0 to K {

      if (status == 0) { 
        nh = h[i * N: N];
        // FIXME : introduce a local function to not duplicate the code
        j = 0;
        // FIXME improve this loop 
        while (j < N) {
          nh[j] = r0;
          j += 1;
        } 
        sroi = (32u)pptsig[OMEGA + i];
        status = 1 if sroi <32u k;
        status = 1 if sroi >32u OMEGA;
        if (status == 0) {
          j = k;
          sjm1 = (32u)pptsig[j];
	  if (j <32u sroi) {
            nh[sjm1] = r1;
	  }
          j += 1; 
          // this is safe because j = k <= OMEGA < OMEGA + K
          sj = (32u)pptsig[j]; 
          while (j <32u sroi) {
            if (sj <=32u sjm1) { 
              status = 1;
              j = sroi; // exit loop
            } else {
              j += 1;
              nh[sj] = r1;
              // for the next iteration
              sjm1 = sj;
              // this is safe because j <= sroi <= OMEGA < OMEGA + K
              sj = (32u)pptsig[j];                
            }              
          }
          k = sroi if (status == 0);
          // END FIXME : local function
        }
        h[i * N : N] = nh; 
      }
    }
    if (status == 0) {
      j = k;
      while(j <32u OMEGA) {
        sj = (32u)pptsig[j];
        if (sj != 0) {
          j = OMEGA;
          status = 1; 
        } else { 
          j += 1; 
        }
      }
    }         

    return c, z, h, status;
}