//NO IMPLEMENTATION AVAILABLE in sign.c
export fn JASMIN_MLDSA87_challenge(reg ptr u32[N] c, reg ptr u8[SEEDBYTES] seed) -> reg ptr u32[N] {
  c = c; seed = seed;
  //TODO
  return c;
}

export fn JASMIN_MLDSA87_crypto_sign_keypair_seed(reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk, reg ptr u8[SEEDBYTES] sb) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES], reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES], reg u32 {
  pk = pk; sk = sk; sb = sb;
  reg u32 status;
  pk, sk, status = _crypto_sign_keypair_seed(pk, sk, sb);
  pk = pk; sk = sk; status = status;
  return pk, sk, status;
}

export fn JASMIN_MLDSA87_crypto_sign_keypair(reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES], reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES], reg u32 {
  pk = pk; sk = sk;
  reg u32 status;
  pk, sk, status = _crypto_sign_keypair(pk, sk);
  pk = pk; sk = sk; status = status;
  return pk, sk, status;
}

export fn JASMIN_MLDSA87_crypto_sign_signature_ctx_internal(reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sig, reg ptr u32[2] ctx_m, reg ptr u32[3] ctxlen_mlen_siglen, reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES], reg u32
{
  sig = sig; ctx_m = ctx_m; ctxlen_mlen_siglen = ctxlen_mlen_siglen; sk = sk;
  reg u32 status;
  sig, status = _crypto_sign_signature_ctx(sig, ctx_m, ctxlen_mlen_siglen, sk);
  sig = sig; status = status;
  return sig, status;
}

export fn JASMIN_MLDSA87_crypto_sign(reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sm, reg u8 m, reg ptr u32[2] smlen_mlen, reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES], reg u32 {
  sm = sm; m = m; smlen_mlen = smlen_mlen; sk = sk;
  reg u32 status;
  sm, status = _crypto_sign(sm, m, smlen_mlen, sk);
  sm = sm; status = status;
  return sm, status;
}

export fn JASMIN_MLDSA87_crypto_sign_verify_ctx_internal(reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sig, reg ptr u32[2] ctx_m, reg ptr u32[3] ctxlen_mlen_siglen, reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    sig = sig; ctx_m = ctx_m; ctxlen_mlen_siglen = ctxlen_mlen_siglen; pk = pk;
    reg u32 status;
    status = _crypto_sign_verify_ctx(sig, ctx_m, ctxlen_mlen_siglen, pk);
    status = status;
    return status;
}

export fn JASMIN_MLDSA87_crypto_sign_open(reg u32 pm, reg u32 sm, reg ptr u32[2] mlen_smlen, reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
  pm = pm; sm = sm; mlen_smlen = mlen_smlen; pk = pk;
  reg u32 status;
  status = _crypto_sign_open(pm, sm, mlen_smlen, pk);
  status = status;
  return status;
}

export fn JASMIN_MLDSA87_shake_inc_0(reg ptr u32[25*2] state, reg u32 pos, reg u32 m, reg u32 mlen) -> reg ptr u32[25*2], reg u32
{
  state = state; pos = pos; m = m; mlen = mlen;
  state, pos = _shake256_inc_absorb_mem_0(state, pos, m, mlen);
  state = state; pos = pos;
  return state, pos;
}

export fn JASMIN_MLDSA87_shake_inc_1(reg ptr u32[25*2] state, reg u32 pos, reg u32 m, reg u32 mlen) -> reg ptr u32[25*2], reg u32
{
  state = state; pos = pos; m = m; mlen = mlen;
  state, pos = _shake256_inc_absorb_mem_1(state, pos, m, mlen);
  state = state; pos = pos;
  return state, pos;
}

export fn JASMIN_MLDSA87_shake_inc_2(reg ptr u32[25*2] state, reg u32 pos, reg u32 m, reg u32 mlen) -> reg ptr u32[25*2], reg u32
{
  state = state; pos = pos; m = m; mlen = mlen;
  state, pos = _shake256_inc_absorb_mem_2(state, pos, m, mlen);
  state = state; pos = pos;
  return state, pos;
}
