/*************************************************
* Name:        JASMIN_MLDSA_pack_pk
*
* Description: Bit-pack public key pk = (rho, t1).
*
* Arguments:   - uint8_t pk[]: output byte array
*              - const uint8_t rho[]: byte array containing rho
*              - const polyveck *t1: pointer to vector t1
**************************************************/
fn _pack_pk(reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk, reg ptr u8[SEEDBYTES] rho, reg ptr u32[polyveck] t1) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] {
    pk = pk; rho = rho; t1 = t1;

    inline int i;

    reg ptr u8[SEEDBYTES] tpk;
    tpk = pk[0:SEEDBYTES];
    tpk = #copy(rho);
    pk[0:SEEDBYTES] = tpk;

    reg ptr u8[POLYT1_PACKEDBYTES] npk;
    reg ptr u32[N] nt1;
    for i = 0 to K {
        nt1 = t1[i * N: N];
        npk = pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES];
        pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES] = _polyt1_pack(npk, nt1);
    }

    return pk;
}

/*************************************************
* Name:        JASMIN_MLDSA_pack_sk
*
* Description: Bit-pack secret key sk = (rho, tr, key, t0, s1, s2).
*
* Arguments:   - uint8_t sk[]: output byte array
*              - const uint8_t rho[]: byte array containing rho
*              - const uint8_t tr[]: byte array containing tr
*              - const uint8_t key[]: byte array containing key
*              - const polyveck *t0: pointer to vector t0
*              - const polyvecl *s1: pointer to vector s1
*              - const polyveck *s2: pointer to vector s2
**************************************************/
fn _pack_sk(reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk, reg ptr u8[SEEDBYTES] rho, reg ptr u8[TRBYTES] tr, reg ptr u8[SEEDBYTES] key, reg ptr u32[polyveck] t0, reg ptr u32[polyvecl] s1, reg ptr u32[polyveck] s2) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] {
    sk = sk; rho = rho; tr = tr; key = key; t0 = t0; s1 = s1; s2 = s2;

    inline int i;
    inline int start_pos;
    start_pos = 0;

    reg ptr u8[SEEDBYTES] tsk;
    reg ptr u8[TRBYTES] ttr;

    tsk = sk[start_pos : SEEDBYTES];
    tsk = #copy(rho);
    sk[start_pos:SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;

    tsk = sk[start_pos :  SEEDBYTES];
    tsk = #copy(key);
    sk[start_pos : SEEDBYTES] = tsk;
    start_pos += SEEDBYTES;

    ttr = sk[start_pos : TRBYTES];
    ttr = #copy(tr);
    sk[start_pos : TRBYTES] = ttr;
    start_pos += TRBYTES;

    reg ptr u8[POLYETA_PACKEDBYTES] nsk;

    () = #spill(t0);
    () = #spill(s2);
    reg ptr u32[N] ns1;
    for i = 0 to L {
        ns1 = s1[i * N: N];
	() = #spill(s1);
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        sk[start_pos : POLYETA_PACKEDBYTES] = _polyeta_pack(nsk, ns1);
	() = #unspill(s1);
	start_pos += POLYETA_PACKEDBYTES;
    }

    () = #unspill(s2);
    reg ptr u32[N] ns2;
    for i = 0 to K {
        ns2 = s2[i * N: N];
	() = #spill(s2);
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        sk[start_pos : POLYETA_PACKEDBYTES] = _polyeta_pack(nsk, ns2);
        () = #unspill(s2);
	start_pos += POLYETA_PACKEDBYTES;
    }
    () = #unspill(t0);

    reg ptr u32[N] nt0;
    reg ptr u8[POLYT0_PACKEDBYTES] nnsk;
    for i = 0 to K {
        nt0 = t0[i * N: N];
        nnsk = sk[start_pos : POLYT0_PACKEDBYTES];
	() = #spill(t0);
        sk[start_pos : POLYT0_PACKEDBYTES] = _polyt0_pack(nnsk, nt0);
	() = #unspill(t0);
	start_pos += POLYT0_PACKEDBYTES;
    }

    return sk;
}

/*************************************************
* Name:        JASMIN_MLDSA_pack_sig
*
* Description: Bit-pack signature sig = (c, z, h).
*
* Arguments:   - uint8_t sig[]: output byte array
*              - const uint8_t *c: pointer to JASMIN_MLDSA_challenge hash length SEEDBYTES
*              - const polyvecl *z: pointer to vector z
*              - const polyveck *h: pointer to hint vector h
**************************************************/
fn _pack_sig(reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sig, reg ptr u8[CTILDEBYTES] c, reg ptr u32[polyvecl] z, reg ptr u32[polyveck] h) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] {
    sig = sig; c = c; z = z; h = h;

    inline int i;

    inline int start_pos;
    start_pos = 0;

    reg ptr u8[CTILDEBYTES] ptsig;
    ptsig = sig[start_pos : CTILDEBYTES];
    // FIXME this copy can be improved using 32 bits load and store instead of 8
    ptsig = #copy(c);
    sig[start_pos : CTILDEBYTES] = ptsig;
    start_pos += CTILDEBYTES;

    reg ptr u32[N] nz;
    reg ptr u8[POLYZ_PACKEDBYTES] nsig;
    for i = 0 to L {
        nz = z[i * N: N];
        nsig = sig[start_pos : POLYZ_PACKEDBYTES];
        sig[start_pos : POLYZ_PACKEDBYTES] = _polyz_pack(nsig, nz);
	start_pos += POLYZ_PACKEDBYTES;
    }

    reg u32 r0;
    r0 = 0;
    reg ptr u8[OMEGA + K]  pptsig;
    pptsig = sig[start_pos : OMEGA + K];
    // FIXME use a while loop ?
    // FIXME use 32 bits 0 ? OMEGA + K = 75 + 8 = 83 = 20 * 4 + 3
    for i = 0 to OMEGA + K {
        pptsig[i] = r0;
    }

    reg u32 j;
    reg u32 hj;
    reg u32 k;
    k = 0;

    reg ptr u32[N] nh;
    for i = 0 to K {
       nh = h[i * N: N];
       j = 0;
       while (j < N) {
         hj = nh[j];
         if hj != 0 {
           pptsig[k] = j;
           k += 1;
         }
	 j += 1;
       }
       pptsig[i + OMEGA] = k;
    }
    sig[start_pos : OMEGA + K] = pptsig;

    return sig;
}

// Same as _pack_sig(sig, sig[0:SEEDBYTES], z, h)
fn _pack_sig_nocopy(reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sig, reg ptr u32[polyvecl] z, reg ptr u32[polyveck] h) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] {
    sig = sig; z = z; h = h;

    inline int i;

    inline int start_pos;
    start_pos = 0;

    start_pos += CTILDEBYTES;

    reg ptr u32[N] nz;
    reg ptr u8[POLYZ_PACKEDBYTES] nsig;
    for i = 0 to L {
        nz = z[i * N: N];
        nsig = sig[start_pos : POLYZ_PACKEDBYTES];
        sig[start_pos : POLYZ_PACKEDBYTES] = _polyz_pack(nsig, nz);
	start_pos += POLYZ_PACKEDBYTES;
    }

    reg u32 r0;
    r0 = 0;
    reg ptr u8[OMEGA + K]  pptsig;
    pptsig = sig[start_pos : OMEGA + K];
    // FIXME use a while loop ?
    // FIXME use 32 bits 0 ? OMEGA + K = 75 + 8 = 83 = 20 * 4 + 3
    for i = 0 to OMEGA + K {
        pptsig[i] = r0;
    }

    reg u32 j;
    reg u32 hj;
    reg u32 k;
    k = 0;

    reg ptr u32[N] nh;
    for i = 0 to K {
       nh = h[i * N: N];
       j = 0;
       while (j < N) {
         hj = nh[j];
         if hj != 0 {
           pptsig[k] = j;
           k += 1;
         }
	 j += 1;
       }
       pptsig[i + OMEGA] = k;
    }
    sig[start_pos : OMEGA + K] = pptsig;

    return sig;
}

/*************************************************
* Name:        JASMIN_MLDSA_unpack_pk
*
* Description: Unpack public key pk = (rho, t1).
*
* Arguments:   - const uint8_t rho[]: output byte array for rho
*              - const polyveck *t1: pointer to output vector t1
*              - uint8_t pk[]: byte array containing bit-packed pk
**************************************************/
fn _unpack_pk(reg ptr u8[SEEDBYTES] rho, reg ptr u32[polyveck] t1, reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk) -> reg ptr u8[SEEDBYTES], reg ptr u32[polyveck] {
    pk = pk; rho = rho; t1 = t1;

    inline int i;

    reg ptr u8[SEEDBYTES] tpk;
    tpk = pk[0 : SEEDBYTES];
    rho = #copy(tpk);

    reg ptr u8[POLYT1_PACKEDBYTES] npk;
    reg ptr u32[N] nt1;
    for i = 0 to K {
        nt1 = t1[i * N: N];
        npk = pk[SEEDBYTES + i * POLYT1_PACKEDBYTES : POLYT1_PACKEDBYTES];
        t1[i * N : N] = _polyt1_unpack(nt1, npk);
    }

    return rho, t1;
}

/*************************************************
* Name:        JASMIN_MLDSA_unpack_sk
*
* Description: Unpack secret key sk = (rho, tr, key, t0, s1, s2).
*
* Arguments:   - const uint8_t rho[]: output byte array for rho
*              - const uint8_t tr[]: output byte array for tr
*              - const uint8_t key[]: output byte array for key
*              - const polyveck *t0: pointer to output vector t0
*              - const polyvecl *s1: pointer to output vector s1
*              - const polyveck *s2: pointer to output vector s2
*              - uint8_t sk[]: byte array containing bit-packed sk
**************************************************/
fn _unpack_sk
  (reg ptr u8[SEEDBYTES] rho,
   reg ptr u8[TRBYTES] tr,
   reg ptr u8[SEEDBYTES] key,
   reg ptr u32[polyveck] t0,
   reg ptr u32[polyvecl] s1,
   reg ptr u32[polyveck] s2,
   reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk)
  -> reg ptr u8[SEEDBYTES], reg ptr u8[TRBYTES], reg ptr u8[SEEDBYTES],
     reg ptr u32[polyveck], reg ptr u32[polyvecl], reg ptr u32[polyveck]
     // rho, tr, key, t0, s1, s2
{
    sk = sk; rho = rho; tr = tr; key = key; t0 = t0; s1 = s1; s2 = s2;

    inline int i;
    inline int start_pos;
    start_pos = 0;

    reg ptr u8[SEEDBYTES] tsk;
    reg ptr u8[TRBYTES] ttr;

    tsk = sk[start_pos : SEEDBYTES];
    rho = #copy(tsk);
    start_pos += SEEDBYTES;

    tsk = sk[start_pos :  SEEDBYTES];
    key = #copy(tsk);
    start_pos += SEEDBYTES;

    ttr = sk[start_pos : TRBYTES];
    tr = #copy(ttr);
    start_pos += TRBYTES;

    reg ptr u8[POLYETA_PACKEDBYTES] nsk;

    () = #spill(t0);
    () = #spill(s2);
    () = #spill(rho);
    () = #spill(tr);
    () = #spill(key);
    reg ptr u32[N] ns1;
    for i = 0 to L {
        ns1 = s1[i * N: N];
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
        s1[i * N: N] = _polyeta_unpack(ns1, nsk);
	start_pos += POLYETA_PACKEDBYTES;
    }

    () = #unspill(s2);
    reg ptr u32[N] ns2;
    for i = 0 to K {
        ns2 = s2[i * N: N];
        nsk = sk[start_pos : POLYETA_PACKEDBYTES];
	() = #spill(sk);
        s2[i * N: N] = _polyeta_unpack(ns2, nsk);
        () = #unspill(sk);
	start_pos += POLYETA_PACKEDBYTES;
    }
    () = #unspill(t0);
    () = #spill(s1, s2);

    reg ptr u32[N] nt0;
    reg ptr u8[POLYT0_PACKEDBYTES] nnsk;
    for i = 0 to K {
        nt0 = t0[i * N: N];
        nnsk = sk[start_pos : POLYT0_PACKEDBYTES];
        t0[i * N: N] = _polyt0_unpack(nt0, nnsk);
	start_pos += POLYT0_PACKEDBYTES;
    }
    () = #unspill(rho);
    () = #unspill(tr);
    () = #unspill(key);
    () = #unspill(s1,s2);
    return rho, tr, key, t0, s1, s2;
}
