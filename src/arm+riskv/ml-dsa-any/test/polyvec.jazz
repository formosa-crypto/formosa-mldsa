export fn JASMIN_MLDSA_polyvecl_uniform_eta(reg ptr u32[polyvecl] v,
  reg ptr u8[CRHBYTES] seed,
  reg u32 nonce
) -> reg ptr u32[polyvecl]
{
  v = v; seed = seed; nonce = nonce;
  v = _polyvecl_uniform_eta(v, seed, nonce);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyvecl_uniform_gamma1(
  reg ptr u32[polyvecl] v,
  reg ptr u8[CRHBYTES] seed,
  reg u32 nonce
) -> reg ptr u32[polyvecl]
{
  v = v; seed = seed; nonce = nonce;
  v = _polyvecl_uniform_gamma1(v, seed, nonce);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyvecl_reduce(reg ptr u32[polyvecl] v) -> reg ptr u32[polyvecl]
{
  v = v;
  v = _polyvecl_reduce(v);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyvecl_add(
  reg ptr u32[polyvecl] w,
  reg ptr u32[polyvecl] u,
  reg ptr u32[polyvecl] v
) -> reg ptr u32[polyvecl]
{
  w = w; u = u; v = v;
  w = __copy_polyvecl(w, v);
  w = _polyvecl_add_inplace(w, u);
  w = w;
  return w;
}

export fn JASMIN_MLDSA_polyvecl_ntt(reg ptr u32[polyvecl] v) -> reg ptr u32[polyvecl] {
   v = v;
   v = _polyvecl_ntt(v);
   v = v;
   return v;
}

export fn JASMIN_MLDSA_polyvecl_invntt_tomont(reg ptr u32[polyvecl] v) -> reg ptr u32[polyvecl] {
  v = v;
  v = _polyvecl_invntt_tomont(v);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyvecl_pointwise_poly_montgomery(
  reg ptr u32[polyvecl] r,
  reg ptr u32[N] a,
  reg ptr u32[polyvecl] v
) -> reg ptr u32[polyvecl] {
   r = r; a = a; v = v;    
   r = _polyvecl_pointwise_poly_montgomery(r, a, v);
   r = r;
   return r;
}

export fn JASMIN_MLDSA_polyvecl_pointwise_acc_montgomery(
  reg ptr u32[N] w,
  reg ptr u32[polyvecl] u,
  reg ptr u32[polyvecl] v
) -> reg ptr u32[N] {
  w = w; u = u; v = v;
  w = _polyvecl_pointwise_acc_montgomery(w, u, v);
  w = w;
  return w;
}

export fn JASMIN_MLDSA_polyvecl_chknorm(reg ptr u32[polyvecl] v, reg u32 bound) -> reg u32 {
  v = v; bound = bound;
  reg u32 r;
  r = _polyvecl_chknorm(v, bound);
  r = r;
  return r;
}

/**************************************************************/
/************ Vectors of polynomials of length K **************/
/**************************************************************/

export fn JASMIN_MLDSA_polyveck_uniform_eta(
  reg ptr u32[polyveck] v, 
  reg ptr u8[CRHBYTES] seed, 
  reg u32 nonce
) -> reg ptr u32[polyveck] {
  v = v; seed = seed; nonce = nonce;
  v = _polyveck_uniform_eta(v, seed, nonce);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyveck_reduce(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] {
  v = v;
  v = _polyveck_reduce(v);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyveck_caddq(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] {
  v = v;
  v = _polyveck_caddq(v);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyveck_add(
  reg ptr u32[polyveck] w,
  reg ptr u32[polyveck] u,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck] 
{
  w = w; u = u; v = v;
  w = __copy_polyveck(w, v);
  w = _polyveck_add_inplace(w, u);
  w = w;
  return w;
}

export fn JASMIN_MLDSA_polyveck_sub(
  reg ptr u32[polyveck] w,
  reg ptr u32[polyveck] u,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck]
{
  w = w; u = u; v = v;
  w = __copy_polyveck(w, u);
  w = _polyveck_sub_inplace(w, v);
  w = w;
  return w;
}

export fn JASMIN_MLDSA_polyveck_shiftl(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] {
  v = v;
  v = _polyveck_shiftl(v);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyveck_ntt(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] {
  v = v;
  v = _polyveck_ntt(v);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyveck_invntt_tomont(reg ptr u32[polyveck] v) -> reg ptr u32[polyveck] {
  v = v;
  v = _polyveck_invntt_tomont(v);
  v = v;
  return v;
}

export fn JASMIN_MLDSA_polyveck_pointwise_poly_montgomery(
  reg ptr u32[polyveck] r,
  reg ptr u32[N] a,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck] {
  r = r; a = a; v = v;    
  r = _polyveck_pointwise_poly_montgomery(r, a, v);
  r = r;
  return r;
}

export fn JASMIN_MLDSA_polyveck_chknorm(reg ptr u32[polyveck] v, reg u32 bound) -> reg u32 {
  v = v; bound = bound;
  reg u32 r;
  r = _polyveck_chknorm(v, bound);
  r = r;
  return r;
}

export fn JASMIN_MLDSA_polyveck_power2round(
  reg ptr u32[polyveck] v1,
  reg ptr u32[polyveck] v0,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck], reg ptr u32[polyveck] {

  v1 = v1; v0 = v0; v = v;
  v1 = __copy_polyveck(v1, v);
  v1, v0 = _polyveck_power2round_inplace(v1, v0);
  v1 = v1; v0 = v0;
  return v1, v0;
}

export fn JASMIN_MLDSA_polyveck_decompose(
  reg ptr u32[polyveck] v1,
  reg ptr u32[polyveck] v0,
  reg ptr u32[polyveck] v
) -> reg ptr u32[polyveck], reg ptr u32[polyveck] {
  v1 = v1; v0 = v0; v = v;
  v1 = __copy_polyveck(v1, v);
  v1, v0 = _polyveck_decompose_inplace(v1, v0);
  v1 = v1; v0 = v0;
  return v1, v0;
}

export fn JASMIN_MLDSA_polyveck_make_hint(
  reg ptr u32[polyveck] h,
  reg ptr u32[polyveck] v0,
  reg ptr u32[polyveck] v1
) -> reg ptr u32[polyveck], reg u32
{
  h = h; v0 = v0; v1 = v1;
  reg u32 s;
  s, h = _polyveck_make_hint(h, v0, v1);
  s = s; h = h;
  return h, s;
}

export fn JASMIN_MLDSA_polyveck_use_hint
(
  reg ptr u32[polyveck] w,
  reg ptr u32[polyveck] u,
  reg ptr u32[polyveck] h
) -> reg ptr u32[polyveck] {
  w = w; u = u; h = h;
  w = __copy_polyveck(w, u);
  w = _polyveck_use_hint_inplace(w, h);
  w = w;
  return w;
}

export fn JASMIN_MLDSA_polyveck_pack_w1(
  reg ptr u8[K * POLYW1_PACKEDBYTES] r,
  reg ptr u32[polyveck] w1
) -> reg ptr u8[K * POLYW1_PACKEDBYTES] {
  r = r; w1 = w1;
  r = _polyveck_pack_w1(r, w1);
  r = r;
  return r;
}

export fn JASMIN_MLDSA_polyvec_matrix_expand(
  reg ptr u32[matKL] mat,
  reg ptr u8[SEEDBYTES] rho
) -> reg ptr u32[matKL] {
  mat = _polyvec_matrix_expand(mat, rho);
  return mat;
}

export fn JASMIN_MLDSA_polyvec_matrix_pointwise_montgomery(
  reg ptr u32[polyveck] t,
  reg ptr u32[matKL] mat,
  reg ptr u32[polyvecl] v
) -> reg ptr u32[polyveck] {
  t = t; mat = mat; v = v;
  t = _polyvec_matrix_pointwise_montgomery(t, mat, v);
  t = t;
  return t;
}
