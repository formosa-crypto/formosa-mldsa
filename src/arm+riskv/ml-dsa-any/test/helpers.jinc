/* ********************************************************************** */
/* Helper functions for the test and export function                      */

/* FIXME move those functions elsewere */

inline fn __mem_to_poly (reg u32 p) -> stack u32[N] {
  stack u32[N] a;
  reg ptr u32[N] pa;
  reg u32 ai i;
  pa = a;
  i = 0;
  while (i < N) {
    ai = (u32)[p + 4 * i];
    pa[(int) i] = ai;
    i += 1;
  }
  a = pa;
  return a;
}

inline fn __poly_to_mem (stack u32[N] a, reg u32 p) {
  reg u32 ai i;
  reg ptr u32[N] pa;
  i = 0;
  pa = a;
  while (i < N) {
    ai = pa[(int) i];
    (u32)[p + 4 * i] = ai;
    i += 1;
  }
}

inline fn __state_to_mem (reg ptr u32[25*2] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;
  while (i < 25*2) {
    ai = pa[(int) i];
    (u32)[p + 4 * i] = ai;
    i += 1;
  }
}

inline fn __buf_to_mem (reg ptr u8[SHAKE256_RATE] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;
  while (i < SHAKE256_RATE) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __mem_to_seed (reg u32 p) -> stack u8[SEEDBYTES] {
  stack u8[SEEDBYTES] a;
  reg ptr u8[SEEDBYTES] pa;
  reg u32 i;
  reg u32 ai;

  pa = a;
  i = 0;
  while (i < SEEDBYTES  / 4) {
    ai = [p + 4*i];
    pa[u32 (int) i] = ai;
    i += 1;
  }
  inline int j;
  reg u8 ai8;
  p = p + (i << 2);
  for j = 0 to SEEDBYTES %4 {
    ai8 = [p + i];
    pa[(int) i] = ai8;
  }
  a = pa;
  return a;
}

inline fn __seed_to_mem (reg ptr u8[SEEDBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;
  while (i < SEEDBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __mem_to_crhseed (reg u32 p) -> stack u8[CRHBYTES] {
  stack u8[CRHBYTES] a;
  reg ptr u8[CRHBYTES] pa;
  reg u32 i;
  reg u32 ai;

  pa = a;
  i = 0;
  while (i < CRHBYTES  / 4) {
    ai = [p + 4*i];
    pa[u32 (int) i] = ai;
    i += 1;
  }
  inline int j;
  reg u8 ai8;
  p = p + (i << 2);
  for j = 0 to CRHBYTES %4 {
    ai8 = [p + i];
    pa[(int) i] = ai8;
  }
  a = pa;
  return a;
}

inline fn __crhseed_to_mem (reg ptr u8[CRHBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;
  while (i < CRHBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __mem_to_polyeta (reg u32 p) -> stack u8[POLYETA_PACKEDBYTES] {
  stack u8[POLYETA_PACKEDBYTES] a;
  reg ptr u8[POLYETA_PACKEDBYTES] pa;
  reg u32 ai i;
  pa = a;
  i = 0;
  while (i < POLYETA_PACKEDBYTES) {
    ai = (32u) (u8)[p + i];
    pa[(int) i] = ai;
    i += 1;
  }
  a = pa;
  return a;
}

inline fn __polyeta_to_mem (reg ptr u8[POLYETA_PACKEDBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;
  while (i < POLYETA_PACKEDBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __mem_to_polyt0 (reg u32 p) -> stack u8[POLYT0_PACKEDBYTES] {
  stack u8[POLYT0_PACKEDBYTES] a;
  reg ptr u8[POLYT0_PACKEDBYTES] pa;
  reg u32 ai i;
  pa = a;
  i = 0;
  while (i < POLYT0_PACKEDBYTES) {
    ai = (32u) (u8)[p + i];
    pa[(int) i] = ai;
    i += 1;
  }
  a = pa;
  return a;
}

inline fn __polyt0_to_mem (reg ptr u8[POLYT0_PACKEDBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;
  while (i < POLYT0_PACKEDBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __mem_to_polyt1 (reg u32 p) -> stack u8[POLYT1_PACKEDBYTES] {
  stack u8[POLYT1_PACKEDBYTES] a;
  reg ptr u8[POLYT1_PACKEDBYTES] pa;
  reg u32 ai i;
  pa = a;
  i = 0;
  while (i < POLYT1_PACKEDBYTES) {
    ai = (32u) (u8)[p + i];
    pa[(int) i] = ai;
    i += 1;
  }
  a = pa;
  return a;
}

inline fn __polyt1_to_mem (reg ptr u8[POLYT1_PACKEDBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;
  while (i < POLYT1_PACKEDBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __mem_to_polyz (reg u32 p) -> stack u8[POLYZ_PACKEDBYTES] {
  stack u8[POLYZ_PACKEDBYTES] a;
  reg ptr u8[POLYZ_PACKEDBYTES] pa;
  reg u32 ai i;
  pa = a;
  i = 0;
  while (i < POLYZ_PACKEDBYTES) {
    ai = (32u) (u8)[p + i];
    pa[(int) i] = ai;
    i += 1;
  }
  a = pa;
  return a;
}

inline fn __polyz_to_mem (reg ptr u8[POLYZ_PACKEDBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;

  while (i < POLYZ_PACKEDBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __polyw1_to_mem (reg ptr u8[POLYW1_PACKEDBYTES] pa, reg u32 p) {
  reg u32 ai i;

  i = 0;

  while (i < POLYW1_PACKEDBYTES) {
    ai = (32u) pa[(int) i];
    (u8)[p + i] = ai;
    i += 1;
  }
}

inline fn __copy_poly(reg ptr u32[N] pb, reg ptr u32[N] pa) -> reg ptr u32[N] {
  reg u32 ai i;

  i = 0;
  while (i < N) {
    ai = pa[(int) i];
    pb[(int) i] = ai;
    i += 1;
  }

  return pb;
}

inline fn __copy_polyveck(reg ptr u32[polyveck] pb, reg ptr u32[polyveck] pa) -> reg ptr u32[polyveck] {
  reg u32 ai i;

  i = 0;
  while (i < polyveck) {
    ai = pa[(int) i];
    pb[(int) i] = ai;
    i += 1;
  }

  return pb;
}

inline fn __copy_polyvecl(reg ptr u32[polyvecl] pb, reg ptr u32[polyvecl] pa) -> reg ptr u32[polyvecl] {
  reg u32 ai i;

  i = 0;
  while (i < polyvecl) {
    ai = pa[(int) i];
    pb[(int) i] = ai;
    i += 1;
  }

  return pb;
}
