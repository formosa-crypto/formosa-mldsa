/*************************************************
* Name:        JASMIN_MLDSA_unpack_sig
*
* Description: Unpack signature sig = (c, z, h).
*
* Arguments:   - uint8_t *c: pointer to output JASMIN_MLDSA_challenge hash
*              - polyvecl *z: pointer to output vector z
*              - polyveck *h: pointer to output hint vector h
*              - const uint8_t sig[]: byte array containing
*                bit-packed signature
*
* Returns 1 in case of malformed signature; otherwise 0.
**************************************************/
fn _unpack_sig(reg ptr u8[CTILDEBYTES] c, 
               reg ptr u32[polyvecl] z, 
               reg ptr u32[polyveck] h, 
               reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sig) ->
         reg ptr u8[CTILDEBYTES], reg ptr u32[polyvecl], reg ptr u32[polyveck], reg u32 {
    // fixme this should be in the export function not here
    sig = sig; c = c; z = z; h = h;

    reg u32 status, r0, r1, j, sj, sjm1, sroi, k;
    inline int i;
    inline int start_pos;
    reg ptr u8[CTILDEBYTES] ptsig;
    reg ptr u8[OMEGA + K] pptsig;
    reg ptr u32[N] nh, nz;
    reg ptr u8[POLYZ_PACKEDBYTES] nsig;

    start_pos = 0;
    ptsig = sig[start_pos : CTILDEBYTES];
    c = #copy(ptsig);
    start_pos += CTILDEBYTES;

    () = #spill(c, h);

    for i = 0 to L {
      nz = z[i * N: N];
      nsig = sig[start_pos : POLYZ_PACKEDBYTES];
      () = #spill(sig, z);
      nz = _polyz_unpack(nz, nsig);
      () = #unspill(sig, z);
      z[i * N: N] = nz;
      start_pos += POLYZ_PACKEDBYTES;
    }

    () = #unspill(c, h);
    status = 0;
    r0 = 0;
    r1 = 1;
    pptsig = sig[start_pos : OMEGA + K];
    k = 0;    
    for i = 0 to K {

      if (status == 0) { 
        nh = h[i * N: N];
        // FIXME : introduce a local function to not duplicate the code
        j = 0;
        // FIXME improve this loop
        while (j < N) {
          nh[j] = r0;
          j += 1;
        } 
        sroi = (32u)pptsig[OMEGA + i];
        if (sroi <32u k) {
           status = 1;
        }

        if (sroi >32u OMEGA) {
           status = 1;
        }
        if (status == 0) {
          j = k;
          sjm1 = (32u)pptsig[j];
	  if (j <32u sroi) {
            nh[sjm1] = r1;
	  }
          j += 1; 
          // this is safe because j = k <= OMEGA < OMEGA + K
          sj = (32u)pptsig[j]; 
          while (j <32u sroi) {
            if (sj <=32u sjm1) { 
              status = 1;
              j = sroi; // exit loop
            } else {
              j += 1;
              nh[sj] = r1;
              // for the next iteration
              sjm1 = sj;
              // this is safe because j <= sroi <= OMEGA < OMEGA + K
              sj = (32u)pptsig[j];                
            }              
          }

          if (status == 0) {
            k = sroi;
          }
          // END FIXME : local function
        }
        h[i * N : N] = nh; 
      }
    }
    if (status == 0) {
      j = k;
      while(j <32u OMEGA) {
        sj = (32u)pptsig[j];
        if (sj != 0) {
          j = OMEGA;
          status = 1; 
        } else { 
          j += 1; 
        }
      }
    }         

    return c, z, h, status;
}
