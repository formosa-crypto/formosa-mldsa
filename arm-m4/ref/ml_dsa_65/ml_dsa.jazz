from Common require "wrappers.jinc"
from Common require "keccakf1600.jinc"
require "params.jinc"
from Common require "params.jinc"
from Common require "reduce.jinc"
from Common require "ntt.jinc"
from Common require "map.jinc"
from Common require "fips202.jinc"
require "rounding.jinc"
from Common require "poly.jinc"
require "poly.jinc"
from Common require "polyvec.jinc"
from Common require "packing.jinc"

require "packing.jinc"
from Common require "ml_dsa.jinc"

export fn ml_dsa_65_keygen(
    reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk,
    reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk,
    reg ptr u8[SEEDBYTES] seed
) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES],
     reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] {
  pk = pk; sk = sk;
  pk, sk = _crypto_sign_keypair_seed(pk, sk, seed);
  pk = pk; sk = sk;
  return pk, sk;
}

export fn ml_dsa_65_sign(
    reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sig,
    reg ptr u32[3] ctx_m_rand,
    reg ptr u32[2] ctxlen_mlen,
    reg ptr u8[JASMIN_MLDSA_CRYPTO_SECRETKEYBYTES] sk
) -> reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES], reg u32
{
  sig = sig; ctx_m_rand = ctx_m_rand; ctxlen_mlen = ctxlen_mlen; sk = sk;
  reg u32 status;
  sig, status = _crypto_sign_signature_ctx_seed(sig, ctx_m_rand, ctxlen_mlen, sk);
  sig = sig; status = status;
  return sig, status;
}

export fn ml_dsa_65_verify(
    reg ptr u8[JASMIN_MLDSA_CRYPTO_BYTES] sig,
    reg ptr u32[2] ctx_m,
    reg ptr u32[2] ctxlen_mlen,
    reg ptr u8[JASMIN_MLDSA_CRYPTO_PUBLICKEYBYTES] pk) -> reg u32 {
    sig = sig; ctx_m = ctx_m; ctxlen_mlen = ctxlen_mlen; pk = pk;
    reg u32 status;
    status = _crypto_sign_verify_ctx(sig, ctx_m, ctxlen_mlen, pk);
    status = status;
    return status;
}
