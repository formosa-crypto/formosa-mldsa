/*inline
fn __decode_hint(
    reg ptr u32[polyveck] hints,
    reg ptr u8[HINT_ENCODED_SIZE] hint_encoded
) -> reg ptr u32[ROWS_IN_MATRIX_A * COEFFICIENTS_IN_POLYNOMIAL], reg u64
{
    reg u64 j;
    reg u8 done;
    reg bool within_bounds;
    reg u64 index;
    reg u64 hint hint_at_j hint_at_j_minus_one;
    reg u64 previous_true_hints_seen current_true_hints_seen;
    reg u64 decoded_offset encoded_offset ill_formed_hint;

    ill_formed_hint = 0;
    previous_true_hints_seen = 0;

    encoded_offset = 0;
    while {
        within_bounds = encoded_offset >= ROWS_IN_MATRIX_A;
        done = #SETcc(within_bounds);
        done |= ill_formed_hint;
    } (done == 0) {
        decoded_offset = encoded_offset;
        decoded_offset <<= LOG_2_COEFFICIENTS_IN_POLYNOMIAL;
        j = 0;

        while (j < COEFFICIENTS_IN_POLYNOMIAL) {
            index = #LEA_64(decoded_offset + j);
            hints[index] = 0;
            j += 1;
        }

        current_true_hints_seen = (64u)hint_encoded[MAX_ONES_IN_HINT + encoded_offset];

        if (current_true_hints_seen < previous_true_hints_seen) {
            ill_formed_hint = 1;
        } else {
            if (previous_true_hints_seen > MAX_ONES_IN_HINT) {
                ill_formed_hint = 1;
            } else {
                j = previous_true_hints_seen;

                while {
                    within_bounds = j >= current_true_hints_seen;
                    done = #SETcc(within_bounds);
                    done |= ill_formed_hint;
                } (done == 0) {
                    // Coefficients are ordered for strong unforgeability
                    hint_at_j = (64u)hint_encoded[j];

                    if (j > previous_true_hints_seen) {
                        hint_at_j_minus_one = (64u)hint_encoded[j - 1];

                        if (hint_at_j <= hint_at_j_minus_one) {
                            ill_formed_hint = 1;
                        }
                    }

                    if (ill_formed_hint == 0) {
                        // h->vec[i].coeffs[sig[j]] = 1;
                        index = #LEA_64(decoded_offset + hint_at_j);
                        hints[index] = 1;

                        j += 1;

                    }
                }
            }
        }

        if (ill_formed_hint == 0) {
            previous_true_hints_seen = current_true_hints_seen;
            encoded_offset += 1;
        }
    }

    encoded_offset = previous_true_hints_seen;
    while {
        within_bounds = encoded_offset >= MAX_ONES_IN_HINT;
        done = #SETcc(within_bounds);
        done |= ill_formed_hint;
    } (done == 0) {
        hint = (64u)hint_encoded[encoded_offset];

        if(hint != 0) {
            ill_formed_hint = 1;
        }
        encoded_offset += 1;
    }

    // Do this so we can indicate success with 0 and failure with -1.
    ill_formed_hint = -ill_formed_hint;

    return hints, ill_formed_hint;
}*/

/*************************************************
 * Name:        JASMIN_MLDSA_unpack_sig
 *
 * Description: Unpack signature sig = (c, z, h).
 *
 * Arguments:   - uint8_t *c: pointer to output JASMIN_MLDSA_challenge hash
 *              - polyvecl *z: pointer to output vector z
 *              - polyveck *h: pointer to output hint vector h
 *              - const uint8_t sig[]: byte array containing
 *                bit-packed signature
 *
 * Returns 1 in case of malformed signature; otherwise 0.
 **************************************************/
fn _unpack_sig(reg ptr u8[CTILDEBYTES] c,
        reg ptr u32[polyvecl] z,
        reg ptr u32[polyveck] h,
        reg ptr u8[SIGNATURE_SIZE] sig) ->
    reg ptr u8[CTILDEBYTES],
    reg ptr u32[polyvecl],
    reg ptr u32[polyveck],
    reg u32
{
    // fixme this should be in the export function not here
    sig = sig; c = c; z = z; h = h;

    reg u32 ill_formed_hint, r0, r1, j, sj, sjm1, sroi, k;
    inline int i;
    inline int current_position;
    reg ptr u8[CTILDEBYTES] ptsig;
    reg ptr u8[MAX_ONES_IN_HINT + K] pointer_to_hint;
    reg ptr u32[N] nh, nz;
    reg ptr u8[POLYZ_PACKEDBYTES] nsig;

    current_position = 0;
    ptsig = sig[current_position : CTILDEBYTES];
    c = #copy(ptsig);
    current_position += CTILDEBYTES;

    () = #spill(c, h);

    for i = 0 to L {
        nz = z[i * N: N];
        nsig = sig[current_position : POLYZ_PACKEDBYTES];
        z[i * N: N] = _polyz_unpack(nz, nsig);
        current_position += POLYZ_PACKEDBYTES;
    }

    () = #unspill(c, h);
    ill_formed_hint = 0;
    r0 = 0;
    r1 = 1;
    pointer_to_hint = sig[current_position : MAX_ONES_IN_HINT + K];
    k = 0;
    for i = 0 to K {

        if (ill_formed_hint == 0) {
            nh = h[i * N: N];
            // FIXME : introduce a local function to not duplicate the code
            j = 0;
            // FIXME improve this loop
            while (j < N) {
                nh[j] = r0;
                j += 1;
            }
            sroi = (32u)pointer_to_hint[MAX_ONES_IN_HINT + i];
            if (sroi <32u k) {
                ill_formed_hint = 1;
            }

            if (sroi >32u MAX_ONES_IN_HINT) {
                ill_formed_hint = 1;
            }
            if (ill_formed_hint == 0) {
                j = k;
                sjm1 = (32u)pointer_to_hint[j];
                if (j <32u sroi) {
                    nh[sjm1] = r1;
                }
                j += 1;
                // this is safe because j = k <= MAX_ONES_IN_HINT < MAX_ONES_IN_HINT + K
                sj = (32u)pointer_to_hint[j];
                while (j <32u sroi) {
                    if (sj <=32u sjm1) {
                        ill_formed_hint = 1;
                        j = sroi; // exit loop
                    } else {
                        j += 1;
                        nh[sj] = r1;
                        // for the next iteration
                        sjm1 = sj;
                        // this is safe because j <= sroi <= MAX_ONES_IN_HINT < MAX_ONES_IN_HINT + K
                        sj = (32u)pointer_to_hint[j];
                    }
                }

                if (ill_formed_hint == 0) {
                    k = sroi;
                }
                // END FIXME : local function
            }
            h[i * N : N] = nh;
        }
    }
    if (ill_formed_hint == 0) {
        j = k;
        while(j <32u MAX_ONES_IN_HINT) {
            sj = (32u)pointer_to_hint[j];
            if (sj != 0) {
                j = MAX_ONES_IN_HINT;
                ill_formed_hint = 1;
            } else {
                j += 1;
            }
        }
    }

    return c, z, h, ill_formed_hint;
}
