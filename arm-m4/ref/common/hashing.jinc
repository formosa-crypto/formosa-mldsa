fn _hash_verification_key(
    reg ptr u8[VERIFICATION_KEY_HASH_SIZE] verification_key_hash,
    reg ptr u8[VERIFICATION_KEY_SIZE] inp
) -> reg ptr u8[VERIFICATION_KEY_HASH_SIZE]
{
    stack u32[25*2] state;
    reg ptr u32[25*2] pstate;
    reg u32 i j t s;

    pstate = state;
    pstate = __keccak_init_ref(pstate);
    () = #spill(verification_key_hash);
    reg u32 last;

    i = 0;
    while {
        last = (VERIFICATION_KEY_SIZE >> 2) - (SHAKE256_RATE >> 2);
    }
    (i < last)
    {
        j = 0;
        while (j < SHAKE256_RATE >> 2) {
            t = inp[:u32 i];
            s = pstate[j];
            t ^= s;
            pstate[j] = t;
            i += 1;
            j += 1;
        }
        () = #spill(i, inp);
        pstate = _keccakf1600_ref(pstate);
        () = #unspill(i, inp);
    }

    j = 0;
    while(i < VERIFICATION_KEY_SIZE >> 2) {
        t = inp[:u32 i];
        s = pstate[j];
        t ^= s;
        pstate[j] = t;
        i += 1;
        j += 1;
    }

    /***
     *  FIXME : replace it by __add_block_end but warning
     ***/
    s = (32u)pstate[:u8 (j * 4)];
    s ^= TRAIL_BYTE;
    pstate[:u8 (j * 4)] = s;
    s = (32u) pstate[:u8 (SHAKE256_RATE - 1)];
    s ^= 128;
    pstate[:u8 (SHAKE256_RATE - 1)] = s;

    pstate = _keccakf1600_ref(pstate);

    () = #unspill(verification_key_hash);
    // FIXME this copy is not necessary if we return pstate, in that case it should be taken as argument
    i = 0;
    while (i < VERIFICATION_KEY_HASH_SIZE / 4) {
        t = pstate[i];
        verification_key_hash[:u32 i] = t;
        i += 1;
    }

    return verification_key_hash;
}

