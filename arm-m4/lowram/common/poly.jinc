inline fn __high(reg u32[2] x) -> reg u32
{
    reg u32 h;
    h = x[1];
    return h;
}

inline fn __low(reg u32[2] x) -> reg u32
{
    reg u32 l;
    l = x[0];
    return l;
}

inline fn __make_64(reg u32 h, reg u32 l) -> reg u32[2]
{
    reg u32[2] y;

    y[0] = l;
    y[1] = h;

    return y;
}

inline fn __shift_right(reg u32[2] x, inline int i) -> reg u32[2]
{
    reg u32 h l;
    h = __high(x);
    l = __low(x);

    l >>= i;
    l = __or_lsl_inplace(l, h, (32 - i));
    h >>= i;

    reg u32[2] y;
    y = __make_64(h, l);

    return y;
}

inline fn __rej_sample(
    reg ptr u32[N] a,
    reg u32 ctr,
    reg u32 t,
    reg u32 q
) -> reg ptr u32[N],
     reg u32
{
    inline bool b;
    b = __cmp_b(t, q);

    if (b) {
        a[ctr] = t;
        ctr = ctr + 1;
    }

    return a, ctr;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_reduce
 *
 * Description: Inplace reduction of all coefficients of polynomial to
 *              representative in [-6283009,6283007].
 *
 * Arguments:   - poly *a: pointer to input/output polynomial
 **************************************************/
fn _poly_reduce(reg ptr u32[N] a) -> reg ptr u32[N]
{
    reg u32 i elem;

    i = 0;
    while(i < N)
    {
        elem = a[i];
        elem = __reduce32(elem);
        a[i] = elem;
        i += 1;
    }

    return a;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_caddq
 *
 * Description: For all coefficients of in/out polynomial add Q if
 *              coefficient is negative.
 *
 * Arguments:   - poly *a: pointer to input/output polynomial
 **************************************************/
fn _poly_caddq(reg ptr u32[N] a) -> reg ptr u32[N]
{
    reg u32 i elem;

    i = 0;
    while(i < N)
    {
        elem = a[i];
        elem = __caddq(elem);
        a[i] = elem;
        i += 1;
    }

    return a;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_add
 *
 * Description: Add polynomials. No modular reduction is performed.
 *
 * Arguments:   - poly *c: pointer to output polynomial
 *              - const poly *a: pointer to first summand
 *              - const poly *b: pointer to second summand
 **************************************************/
inline fn __poly_add_body(reg u32 coeff_a, reg u32 coeff_b) -> reg u32
{
    coeff_a = coeff_a + coeff_b;
    return coeff_a;
}

fn _poly_add_inplace(reg ptr u32[N] a b) -> reg ptr u32[N]
{
    reg u32 i coeff_a coeff_b;

    i = 0;
    while(i < N)
    {
        coeff_a = a[i];
        coeff_b = b[i];
        coeff_a = __poly_add_body(coeff_a, coeff_b);
        a[i] = coeff_a;

        i += 1;
    }

    return a;
}

/**************************************************
 * Name:        JASMIN_MLDSA_poly_check_norm
 *
 * Description: Check infinity norm of polynomial against given bound.
 *              Assumes input coefficients were reduced by JASMIN_MLDSA_reduce32().
 *
 * Arguments:   - const poly *a: pointer to polynomial
 *              - int32_t B: norm bound
 *
 * Returns 0 if norm is strictly smaller than B <= (Q-1)/8 and 1 otherwise.
 **************************************************/
fn _poly_check_norm(reg ptr u32[N] a, reg u32 B) -> reg u32 {
    reg u32 r;
    reg u32 q;
    r = 0;
    q = iQ;
    q -= 1;
    q = q >> 3;

    if (B >s q) {
        r = 1;
    }

    reg u32 t;

    reg u32 i; i = 0;
    while {
        #declassify t = a[i];
        t = -t if t <s 0;

        i += 1;

        if (t >=s B) {
            r = 1;
            i = N;
        }

    } (i != N)

    return r;
}

inline fn __eta_minus_coeff(reg ptr u32[N] a, reg u32 i) -> reg u32 {
    reg u32 c;
    c = a[i];
    c = __imm_sub_reg(ETA, c);
    return c;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_use_hint
 *
 * Description: Use hint polynomial to correct the high bits of a polynomial.
 *
 * Arguments:   - poly *b: pointer to output polynomial with corrected high bits
 *              - const poly *a: pointer to input polynomial
 *              - const poly *h: pointer to input hint polynomial
 **************************************************/

fn _poly_use_hint(
    reg ptr u32[N] polynomial,
    reg ptr u8[MAX_ONES_IN_HINT] hints,
    reg u32 number_of_hints
) -> reg ptr u32[N] {
    reg u32 i coefficient hint indicator;
    reg u32 hint_index;
    reg u32 in_list;

    reg u32 done;
    reg bool out_of_bounds;

    i = 0;
    while (i < N) {
        in_list = 0;

        hint_index = 0;

        while {
            out_of_bounds = hint_index >= number_of_hints;
            done = in_list;
            done = 1 if (out_of_bounds);
        } (done == 0) {
            indicator = (32u)hints[hint_index];
            if (i == indicator) {
                in_list = 1;
            }

            hint_index += 1;
        }

        if (in_list == 1) {
            hint = 1;
        } else {
            hint = 0;
        }

        coefficient = polynomial[i];
        coefficient = __use_hint(coefficient, hint);

        polynomial[i] = coefficient;
        i += 1;
    }

    return polynomial;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_pointwise_montgomery
 *
 * Description: Pointwise multiplication of polynomials in NTT domain
 *              representation and multiplication of resulting polynomial
 *              by 2^{-32}.
 *
 * Arguments:   - poly *c: pointer to output polynomial
 *              - const poly *a: pointer to first input polynomial
 *              - const poly *b: pointer to second input polynomial
 **************************************************/
fn _poly_pointwise_montgomery(reg ptr u32[N] c, reg ptr u32[N] a, reg ptr u32[N] b) -> reg ptr u32[N] {
    reg u32 i, a_, b_, c_;
    i = 0;
    while(i < N)
    {
        a_ = a[i]; b_ = b[i];
        c_ = __mul_montgomery_reduce(a_, b_);
        c[i] = c_;
        i += 1;
    }
    return c;
}

fn _poly_pointwise_montgomery_inplace(reg ptr u32[N] c, reg ptr u32[N] a) -> reg ptr u32[N] {
    reg u32 i, a_, c_;
    i = 0;
    while(i < N)
    {
        a_ = a[i];
        c_ = c[i];
        c_ = __mul_montgomery_reduce(a_, c_);
        c[i] = c_;
        i += 1;
    }
    return c;
}

fn _poly_make_hint_inplace(
    reg ptr u32[N] polynomial,
    reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] w_compressed
) -> reg ptr u32[N],
     reg u32
{
    reg u32 w_coeff poly_coeff;
    reg u32 offset;
    reg u32 num_hints = 0;
    reg u32 i = 0;
    reg u32 three_byte_mask = (1 << 24) - 1;

    while (i < N)
    {
        offset = 3;
        offset *= i;
        w_coeff = w_compressed.[:u32 offset];
        w_coeff &= three_byte_mask;

        poly_coeff = polynomial[i];
        w_coeff += poly_coeff;

        poly_coeff = -poly_coeff;
        poly_coeff = __make_hint(poly_coeff, w_coeff);

        polynomial[i] = poly_coeff;
        if (poly_coeff == 1) {
            num_hints += 1;
        }

        i += 1;
    }
    return polynomial, num_hints;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_power2round
 *
 * Description: For all coefficients c of the input polynomial,
 *              compute c0, c1 such that c mod Q = c1*2^D + c0
 *              with -2^{D-1} < c0 <= 2^{D-1}. Assumes coefficients to be
 *              standard representatives.
 *
 * Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
 *              - poly *a0: pointer to output polynomial with coefficients c0
 *              - const poly *a: pointer to input polynomial
 **************************************************/
fn _poly_power2round_inplace(reg ptr u32[N] a1, reg ptr u32[N] a0) -> reg ptr u32[N], reg ptr u32[N] {
    reg u32 i, a_, a0_, a1_;

    i = 0;
    while(i < N)
    {
        a_ = a1[i];
        a0_, a1_ = __power2round_a0a1(a_);
        a0[i] = a0_; a1[i] = a1_;
        i += 1;
    }
    return (a1, a0);
}

/*************************************************
 * Name:        JASMIN_MLDSA_challenge
 *
 * Description: Implementation of H. Samples polynomial with TAU nonzero
 *              coefficients in {-1,1} using the output stream of
 *              SHAKE256(seed).
 *
 * Arguments:   - poly *c: pointer to output polynomial
 *              - const uint8_t mu[]: byte array containing seed of length SEEDBYTES
 **************************************************/
fn _poly_generate_challenge(
    reg ptr u32[25 * 2] state,
    reg ptr u32[N] challenge,
    reg ptr u8[COMMITMENT_HASH_SIZE] commitment_hash
) -> reg ptr u32[25 * 2],
     reg ptr u32[N]
{
    () = #spill(challenge);
    state = __shake256_init_with_commitment_hash(state, commitment_hash);
    () = #unspill(challenge);

    reg u32[2] signs;
    stack u32[2] s_signs;

    reg u32 aux, pos, i;
    signs[0] = state[:u32 0];
    signs[1] = state[:u32 1];

    pos = 8;

    aux = 0;
    i = 0;
    while (i < N) {
        challenge[i] = aux;
        i += 1;
    }

    reg u32 j;
    j = N - TAU;
    reg u32 b;
    while (j < N) {
        while {
            if (pos >= SHAKE256_RATE) {
                pos = 0;

                () = #spill(j, challenge, pos);
                s_signs = #copy(signs);
                state = _keccakf1600_ref(state);

                () = #unspill(j, challenge, pos);
                signs = #copy(s_signs);
            }

            b = (32u) state[:u8 pos];
            pos += 1;
        } (b > j)

        aux = challenge[b];
        challenge[j] = aux;

        aux = signs[0] & 1;
        aux <<= 1;
        aux = __imm_sub_reg(1, aux);
        challenge[b] = aux;

        signs = __shift_right(signs, 1);

        j += 1;
    }

    return state, challenge;
}

inline fn __t1_by_challenge_helper(
    reg ptr u32[N] product,
    reg u32 sign,
    reg u32 index,
    reg ptr u8[POLYT1_PACKEDBYTES] t1_element_packed
) -> reg ptr u32[N] {
    reg u32 j offset;
    reg u32 lhs rhs;

    if (sign == 0) {
        j = 0;
        while {
            offset = index + j;
        } (offset < N) {
            lhs = product[offset];
            rhs = _t1_unpack_coefficient_at_index(t1_element_packed, j);

            lhs += rhs;

            product[offset] = lhs;

            j += 1;
        }

        j = N;
        j -= index;
        while (j < N) {
            offset = -N;
            offset += index;
            offset += j;

            lhs = product[offset];
            rhs = _t1_unpack_coefficient_at_index(t1_element_packed, j);

            lhs -= rhs;

            product[offset] = lhs;

            j += 1;
        }
    } else {
        j = 0;
        while {
            offset = index + j;
        } (offset < N) {
            lhs = product[offset];
            rhs = _t1_unpack_coefficient_at_index(t1_element_packed, j);

            lhs -= rhs;

            product[offset] = lhs;

            j += 1;
        }

        j = N;
        j -= index;
        while (j < N) {
            offset = -N;
            offset += index;
            offset += j;

            lhs = product[offset];
            rhs = _t1_unpack_coefficient_at_index(t1_element_packed, j);

            lhs += rhs;

            product[offset] = lhs;

            j += 1;
        }
    }

    return product;
}

fn _poly_schoolbook_multiply_t1_by_challenge(
    reg ptr u32[N] product,
    reg ptr u8[POLYT1_PACKEDBYTES] t1_element_packed,
    reg ptr u8[COMPRESSED_CHALLENGE_SIZE] compressed_challenge
) -> reg ptr u32[N]
{
    reg u32 sign signs index;

    reg u32 i zero;

    i = 0;
    zero = 0;
    while (i < N) {
        product[i] = zero;
        i += 1;
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 8];
    i = 0;
    while (i < 32) {
        index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        product = __t1_by_challenge_helper(product, sign, index, t1_element_packed);
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 4];
    while (i < TAU) {
        index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        product = __t1_by_challenge_helper(product, sign, index, t1_element_packed);
    }

    return product;
}

inline fn __t0_by_challenge_helper(
    reg ptr u32[N] product,
    reg u32 sign,
    reg u32 index,
    reg ptr u8[POLYT0_PACKEDBYTES] t0_element_packed
) -> reg ptr u32[N] {
    reg u32 j offset;
    reg u32 lhs rhs;

    if (sign == 0) {
        j = 0;
        while {
            offset = index + j;
        } (offset < N) {
            lhs = product[offset];
            rhs = _t0_unpack_coefficient_at_index(t0_element_packed, j);

            lhs += rhs;

            product[offset] = lhs;

            j += 1;
        }

        j = N;
        j -= index;
        while (j < N) {
            offset = -N;
            offset += index;
            offset += j;

            lhs = product[offset];
            rhs = _t0_unpack_coefficient_at_index(t0_element_packed, j);

            lhs -= rhs;

            product[offset] = lhs;

            j += 1;
        }
    } else {
        j = 0;
        while {
            offset = index + j;
        } (offset < N) {
            lhs = product[offset];
            rhs = _t0_unpack_coefficient_at_index(t0_element_packed, j);

            lhs -= rhs;

            product[offset] = lhs;

            j += 1;
        }

        j = N;
        j -= index;
        while (j < N) {
            offset = -N;
            offset += index;
            offset += j;

            lhs = product[offset];
            rhs = _t0_unpack_coefficient_at_index(t0_element_packed, j);

            lhs += rhs;

            product[offset] = lhs;

            j += 1;
        }
    }

    return product;
}
fn _poly_schoolbook_multiply_t0_by_challenge(
    reg ptr u32[N] product,
    reg ptr u8[POLYT0_PACKEDBYTES] t0_element_packed,
    reg ptr u8[COMPRESSED_CHALLENGE_SIZE] compressed_challenge
) -> reg ptr u32[N]
{
    reg u32 sign signs index;

    reg u32 i zero;

    i = 0;
    zero = 0;
    while (i < N) {
        product[i] = zero;
        i += 1;
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 8];
    i = 0;
    while (i < 32) {
        index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        product = __t0_by_challenge_helper(product, sign, index, t0_element_packed);
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 4];
    while (i < TAU) {
        index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        product = __t0_by_challenge_helper(product, sign, index, t0_element_packed);
    }

    return product;
}

fn _poly_add_to_compressed_product_at_index(
    reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] compressed_product,
    reg u32 coeff,
    reg u32 index
) -> reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING]
{
    reg u32 w1_coeff;
    reg u32 offset = 0;
    reg u32 three_byte_mask = (1 << 24) - 1;

    offset = 3;
    offset *= index;

    w1_coeff = compressed_product.[:u32 offset];
    w1_coeff &= three_byte_mask;

    w1_coeff += coeff;
    w1_coeff = _freeze(w1_coeff);

    compressed_product.[:u16 offset] = (16u)w1_coeff;
    w1_coeff >>= 16;
    offset += 2;

    compressed_product[offset] = (8u)w1_coeff;

    return compressed_product;
}
fn _poly_compute_A_times_polynomial(
    reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] compressed_product,
    reg ptr u32[25 * 2] xof_state, // for A
    reg ptr u8[SEEDBYTES] rho,
    reg u32 nonce,
    reg ptr u32[N] polynomial
) -> reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING],
     reg ptr u32[25 * 2]
{
    reg u32 sampled;
    reg u32 xof_offset;
    reg u32 coeff mask;

    inline bool b;

    () = #spill(polynomial, compressed_product);

    xof_state = _prepare_xof_for_element_of_A(xof_state, rho, nonce);

    sampled = 0;
    while (sampled < N) {
        () = #spill(sampled);
        xof_state = _keccakf1600_ref(xof_state);
        () = #unspill(sampled);
        xof_offset = 0;
        while (xof_offset < SHAKE128_RATE) {
            if (sampled < N) {
                coeff = xof_state.[:u32 xof_offset];
                xof_offset += 3;

                mask = 0x7F_FF_FF;
                coeff &= mask;

                b = __cmp_b(coeff, iQ);
                if (b) {
                    () = #unspill(polynomial);
                    coeff = __mul_montgomery_reduce(coeff, polynomial[sampled]);

                    () = #unspill(compressed_product);
                    compressed_product = _poly_add_to_compressed_product_at_index(compressed_product, coeff, sampled);
                    () = #spill(compressed_product);

                    sampled += 1;
                }
            } else {
                // We're done, break out of this loop.
                xof_offset = SHAKE128_RATE;
            }
        }
    }

    return compressed_product, xof_state;
}

fn _poly_decompress_w1_element(
    reg ptr u32[N] w1_element,
    reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] compressed_w1_element
) -> reg ptr u32[N]
{
    reg u32 coeff;
    reg u32 i;
    reg u32 offset;
    reg u32 three_byte_mask = (1 << 24) - 1;

    i = 0;
    while (i < N) {
        offset = 3;
        offset *= i;
        coeff = compressed_w1_element.[:u32 offset];
        coeff &= three_byte_mask;

        w1_element[i] = coeff;
        i += 1;
    }

    return w1_element;
}
fn _poly_compress_w1_element(
    reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] compressed_w1_element,
    reg ptr u32[N] w1_element
) -> reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING]
{
    reg u32 coeff;
    reg u32 i;
    reg u32 offset;

    i = 0;
    while (i < N) {
        offset = 3;
        offset *= i;

        coeff = w1_element[i];
        i += 1;

        compressed_w1_element.[:u32 offset] = coeff;
    }

    return compressed_w1_element;
}

fn _poly_subtract_from_compressed_w1_element(
    reg ptr u32[N] polynomial,
    reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] compressed_w1_element
) -> reg ptr u32[N]
{
    reg u32 coeff w1_coeff;
    reg u32 i;
    reg u32 offset;
    reg u32 three_byte_mask = (1 << 24) - 1;

    i = 0;
    while (i < N) {
        offset = 3;
        offset *= i;
        w1_coeff = compressed_w1_element.[:u32 offset];
        w1_coeff &= three_byte_mask;

        coeff = polynomial[i];
        w1_coeff -= coeff;

        polynomial[i] = w1_coeff;
        i += 1;
    }

    return polynomial;
}

inline fn __zero_compressed_w_element(
    reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] compressed_w_element
) -> reg ptr u8[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING]
{
    reg u32 zero = 0;
    reg u32 i = 0;
    while (i < COMPRESSED_W1_ELEMENT_SIZE) {
        compressed_w_element.[:u32 i] = zero;
        i += 4;
    }
    compressed_w_element[COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING - 1] = (8u)zero;

    return compressed_w_element;
}

fn _poly_high_bits_inplace(reg ptr u32[N] poly) -> reg ptr u32[N]
{
    reg u32 coeff;
    reg u32 i = 0;
    while (i < N) {
        coeff = poly[i];
        coeff = __coefficient_high_bits(coeff);

        poly[i] = coeff;
        i += 1;
    }

    return poly;
}

fn _poly_low_bits_inplace(reg ptr u32[N] poly) -> reg ptr u32[N]
{
    reg u32 coeff;
    reg u32 i = 0;
    while (i < N) {
        coeff = poly[i];
        coeff = __coefficient_low_bits(coeff);

        poly[i] = coeff;
        i += 1;
    }

    return poly;
}

inline fn __extr_rej_sample(
        reg ptr u32[N] a,
        reg u32 ctr,
        reg u32 t,
        reg u32 q
        ) -> reg ptr u32[N], reg u32
{
    t = __ubfx(t, 0, 23);
    a, ctr = __rej_sample(a, ctr, t, q);
    return a, ctr;
}

fn _poly_uniform(
    reg ptr u32[N] sampled,
    reg ptr u32[25 * 2] state
) -> reg ptr u32[N],
     reg ptr u32[25 * 2]
{
    reg u32 ctr, ctr4, pos, q, t;
    reg u32[3] buf;

    ctr = 0; pos = 0; q = iQ;

    while { ctr4 = ctr + 4; } (ctr4 < N) {
        state, sampled, pos, ctr, q, buf = _stream128_refill_buffer(state, sampled, pos, ctr, q);

        sampled, ctr = __extr_rej_sample(sampled, ctr, buf[0], q);  // 3 bytes in buf[0]

        t = buf[0] >>u 24;
        t = __or_lsl_inplace(t, buf[1], 8);
        sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);

        t = buf[1] >>u 16;
        t = __or_lsl_inplace(t, buf[2], 16);  // 2 byte in buf[1] U 1 bytes in buf[2]
        sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);

        t = __ubfx(buf[2], 8, 23);
        sampled, ctr = __rej_sample(sampled, ctr, t, q);
    }

    while (ctr < N) {
        state, sampled, pos, ctr, q, buf = _stream128_refill_buffer(state, sampled, pos, ctr, q);

        sampled, ctr = __extr_rej_sample(sampled, ctr, buf[0], q);  // 3 bytes in buf[0]

        if (ctr < N) {
            t = buf[0] >>u 24;
            t = __or_lsl_inplace(t, buf[1], 8); // 1 byte in buf[0] U 2 bytes in buf[1]
            sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);
        }

        if (ctr < N) {
            t = buf[1] >>u 16;
            t = __or_lsl_inplace(t, buf[2], 16); // 2 byte in buf[1] U 1 bytes in buf[2]
            sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);
        }

        if (ctr < N) {
            t = __ubfx(buf[2], 8, 23);
            sampled, ctr = __rej_sample(sampled, ctr, t, q);
        }
    }

    return sampled, state;
}

fn _poly_uniform_eta(
    reg ptr u32[N] poly,
    #secret reg ptr u8[CRHBYTES] seed,
    reg u32 nonce
) -> reg ptr u32[N]
{
    stack u32[25*2] state;
    reg u32 ctr, ctr8, pos, n205, t;
    reg u32 buf;

    () = #spill(poly);
    state = _prepare_state_for_shake256(state, seed, nonce);
    state = _keccakf1600_ref(state);
    () = #unspill(poly);

    ctr = 0;
    pos = 0;
    n205 = 205;
    while {
        ctr8 = ctr + 8;
    } (ctr8 < N) {

        state, poly, pos, ctr, n205, buf = _stream256_refill_buffer(state, poly, pos, ctr, n205);
        inline int i;
        for i = 0 to 8 {
            t = __ubfx(buf, 4*i, 4);
            poly, ctr = rej_eta(poly, ctr, t);
        }
    }

    while (ctr < N) {
        state, poly, pos, ctr, n205, buf = _stream256_refill_buffer(state, poly, pos, ctr, n205);
        inline int i;
        for i = 0 to 8 {
            if ((i == 0) || (ctr < N)) {
                t = __ubfx(buf, 4*i, 4);
                poly, ctr = rej_eta(poly, ctr, t);
            }
        }
    }
    return poly;
}


