/*************************************************
 * Description: Verifies signature.
 *
 * Arguments:   - uint8_t *m: pointer to input signature
 *              - size_t siglen: length of signature
 *              - const uint8_t *m: pointer to message
 *              - size_t mlen: length of message
 *              - const uint8_t *ctx: pointer to context string
 *              - size_t ctxlen: length of context string
 *              - const uint8_t *pk: pointer to bit-packed public key
 *
 * Returns 0 if signature could be verified correctly and -1 otherwise
 **************************************************/
fn _crypto_sign_verify_ctx(
        reg ptr u8[SIGNATURE_SIZE] sig,
        reg ptr u32[2] ctx_m,
        reg ptr u32[2] ctxlen_mlen,
        reg ptr u8[VERIFICATION_KEY_SIZE] verification_key
) -> reg u32 {
    reg u32 status;

    stack u8[SEEDBYTES] rho;
    stack u8[CRHBYTES] crh_byte_hash;
    stack u8[COMMITMENT_HASH_SIZE] commitment_hash;

    stack u32[polyvecl] signer_response;
    reg ptr u32[polyvecl] signer_response_ptr;

    stack u32[polyveck] t1;
    reg ptr u32[polyveck] t1_ptr;

    stack u32[polyveck] hint;
    reg ptr u32[polyveck] hint_ptr;

    stack u32[N] matrix_element w1_element product;
    stack u32[25*2] state;
    stack u32[N] challenge;
    stack u8[POLYW1_PACKEDBYTES] w1_element_packed;

    reg u32 ctxlen m mlen ctx t pos;
    reg ptr u32[25*2] pstate;
    reg ptr u8[2] message_prefix;

    inline int i column_number row_number;

    ctxlen = ctxlen_mlen[0];

    if (ctxlen <= 255) {
        () = #spill(ctxlen_mlen, ctx_m, ctxlen);
        rho, t1 = _unpack_pk(rho, t1, verification_key);

        () = #spill(verification_key);
        commitment_hash, signer_response, hint, status = _unpack_sig(commitment_hash, signer_response, hint, sig);
        () = #spill(sig);

        if (status == 0) {
            reg u32 bound;
            bound = iGAMMA1 - BETA;
            status = _polyvecl_chknorm(signer_response, bound);

            if (status == 0) {
                () = #unspill(verification_key);
                crh_byte_hash = _hash_verification_key(crh_byte_hash, verification_key);

                pstate = state;

                // VERIFICATION_KEY_HASH_SIZE (64) + 2 < SHAKE256_RATE (136)
                pstate = __add_crh_ref(pstate, crh_byte_hash); // VERIFICATION_KEY_HASH_SIZE = CRHBYTES

                message_prefix = crh_byte_hash[0 : 2];
                t = 0;
                message_prefix[0] = (8u)t;

                () = #unspill(ctxlen_mlen);
                t = ctxlen_mlen[0];
                () = #spill(ctxlen_mlen);

                message_prefix[1] = (8u)t;
                () = #spill(t);

                crh_byte_hash[0 : 2] = message_prefix;

                pstate = __add_message_prefix(pstate, VERIFICATION_KEY_HASH_SIZE, message_prefix);
                () = #spill(message_prefix);
                pstate = __add_zero_after_add_naive(pstate, VERIFICATION_KEY_HASH_SIZE + 2);
                pos = VERIFICATION_KEY_HASH_SIZE + 2;

                () = #unspill(ctx_m);
                ctx = ctx_m[0];
                () = #spill(ctx_m);

                () = #unspill(ctxlen);
                pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, ctx, ctxlen);

                () = #unspill(ctxlen_mlen);
                mlen = ctxlen_mlen[1];

                () = #unspill(ctx_m);
                m = ctx_m[1];
                pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, m, mlen);
                pstate = _shake256_add_block_end(pstate, pos);
                pstate = _keccakf1600_ref(pstate);

                for i = 0 to CRHBYTES/4 {
                    t = pstate[i];
                    crh_byte_hash[:u32 i] = t;
                }
                () = #spill(pstate);

                challenge = _poly_challenge(challenge, commitment_hash);
                challenge = _poly_ntt(challenge);
                signer_response = _polyvecl_ntt(signer_response);

                t1 = _polyveck_shiftl(t1);
                t1 = _polyveck_ntt(t1);

                () = #unspill(pstate);
                pstate = __add_crh_ref(pstate, crh_byte_hash);
                pstate = __add_zero_after_add(pstate, CRHBYTES);
                pos = CRHBYTES;
                () = #spill(pstate, pos);

                for row_number = 0 to K {
                    // Multiply Az first and store it in w1_element
                    matrix_element = __polyvec_matrix_expand_one_element(matrix_element, rho, row_number, 0);
                    w1_element = _poly_pointwise_montgomery(w1_element, matrix_element, signer_response[0 : N]);

                    for column_number = 1 to L {
                        matrix_element = __polyvec_matrix_expand_one_element(matrix_element, rho, row_number, column_number);
                        signer_response_ptr = signer_response;
                        product = _poly_pointwise_montgomery(product, matrix_element, signer_response_ptr[column_number * N : N]);
                        w1_element = _poly_add_inplace(w1_element, product);
                    }

                    t1_ptr = t1;
                    product = _poly_pointwise_montgomery(product, t1_ptr[row_number * N : N], challenge);

                    w1_element = _poly_sub_inplace(w1_element, product);
                    w1_element = _poly_reduce(w1_element);
                    w1_element = _poly_invntt_tomont(w1_element);
                    w1_element = _poly_caddq(w1_element);

                    hint_ptr = hint;
                    w1_element = _poly_use_hint_inplace(w1_element, hint_ptr[row_number * N : N]);
                    w1_element_packed = _polyw1_pack(w1_element_packed, w1_element);

                    () = #unspill(pstate, pos);
                    pstate, pos = _shake256_absorb_w1_element(pstate, pos, w1_element_packed);
                    () = #spill(pstate, pos);
                }
                () = #unspill(pstate, pos);
                pstate = _shake256_add_block_end(pstate, pos);
                pstate = _keccakf1600_ref(pstate);

                reg u32 ci c2i;
                status = 0;
                for i = 0 to COMMITMENT_HASH_SIZE {
                    if (status == 0) {
                        ci = (32u)commitment_hash[i];
                        #declassify c2i = (32u)pstate[:u8 i];
                        if (ci != c2i) {
                            status = i + 1;
                        }
                    }
                }
            }
        }
    }

    if (status != 0) {
        status = -1;
    }

    return status;
}
