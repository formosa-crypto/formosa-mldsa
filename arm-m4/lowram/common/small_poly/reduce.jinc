param int SMALL_Q_INVERSE = 62209; /* q^(-1) mod 2^16 */
param int MONT = 2285; /* 2^16 % Q */
param int BARRETT_R = 20159; /* (1U << 26)/SMALL_Q + 1 */

inline fn __fqmul(reg u32 a b) -> reg u32
{
    reg u32 ad bd c t u;
    reg u32 qinv_shift mmlkem_q;
    reg u32 r;

    ad = (32s)a;
    bd = (32s)b;
    c = ad * bd;

    // merge multiplication of u (<<16)
    qinv_shift = SMALL_Q_INVERSE << 16;
    u = c * qinv_shift;

    u >>s= 16;
    mmlkem_q = -SMALL_Q;
    t = u * mmlkem_q; // replace sub by add
    t += c;
    t >>s= 16;
    r = t;

    return r;
}

inline
fn __barrett_reduce(reg u32 a) -> reg u32
{
    reg u32 t;
    reg u32 r;
    reg u32 barr mlkem_q;
    t = (32s)a;
    barr = BARRETT_R;
    t = t * barr;
    t += (1 << 25);

    t >>s= 26;

    // Arm does not support multiplication with immediate this large
    mlkem_q = SMALL_Q;
    t *= mlkem_q;

    r = a;
    r -= t;
    return r;
}
