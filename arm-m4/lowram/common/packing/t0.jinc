/*************************************************
* Name:        JASMIN_MLDSA_polyt0_pack
*
* Description: Bit-pack polynomial t0 with coefficients in ]-2^{D-1}, 2^{D-1}].
*
* Arguments:   - uint8_t *r: pointer to output byte array with at least
*                            POLYT0_PACKEDBYTES bytes
*              - const poly *a: pointer to input polynomial
**************************************************/
fn _polyt0_pack(reg ptr u8[POLYT0_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYT0_PACKEDBYTES] {
  reg u32 i, j, aux;
  reg u32[7] t;
  reg u32 t7;
  inline int k;

  i = 0; j = 0;
  while(i < N)
  {
    for k = 0 to 7 {
      t[k] = a[i]; i += 1;
      t[k] = __imm_sub_reg((1 << (D - 1)), t[k]);
    }
    /* r[13 * i + 0]  =  (uint8_t) t[0];           */
    r[j] = t[0]; j += 1;   // j = 1

    /* r[13 * i + 1]  =  (uint8_t) (t[0] >>  8);   */
    /* r[13 * i + 1] |=  (uint8_t) (t[1] <<  5);   */
    aux = t[0] >> 8;
    aux = __or_lsl_inplace(aux, t[1], 5);
    r[j] = aux; j += 1;  // j = 2

    /* r[13 * i + 2]  =  (uint8_t) (t[1] >>  3);   */
    aux = t[1] >> 3;
    r[j] = aux; j += 1;   // j = 3

    /* r[13 * i + 3]  =  (uint8_t) (t[1] >> 11);   */
    /* r[13 * i + 3] |=  (uint8_t) (t[2] <<  2);   */
    aux = t[1] >> 11;
    aux = __or_lsl_inplace(aux, t[2], 2);
    r[j] = aux; j += 1;  // j = 4

    /* r[13 * i + 4]  =  (uint8_t) (t[2] >>  6);   */
    /* r[13 * i + 4] |=  (uint8_t) (t[3] <<  7);   */
    aux = t[2] >> 6;
    aux = __or_lsl_inplace(aux, t[3], 7);
    r[j] = aux; j += 1; // j = 5

    /* r[13 * i + 5]  =  (uint8_t) (t[3] >>  1);   */
    aux = t[3] >> 1;
    r[j] = aux; j += 1; // j = 6

    /* r[13 * i + 6]  =  (uint8_t) (t[3] >>  9);   */
    /* r[13 * i + 6] |=  (uint8_t) (t[4] <<  4);   */
    aux = t[3] >> 9;
    aux = __or_lsl_inplace(aux, t[4], 4);
    r[j] = aux; j += 1; // j = 7

    /* r[13 * i + 7]  =  (uint8_t) (t[4] >>  4);   */
    aux = t[4] >> 4;
    r[j] = aux; j += 1;  // j = 8

    /* r[13 * i + 8]  =  (uint8_t) (t[4] >> 12);   */
    /* r[13 * i + 8] |=  (uint8_t) (t[5] <<  1);   */
    aux = t[4] >> 12;
    aux = __or_lsl_inplace(aux, t[5], 1);
    r[j] = aux; j += 1;  // j = 9

    /* r[13 * i + 9]  =  (uint8_t) (t[5] >>  7);   */
    /* r[13 * i + 9] |=  (uint8_t) (t[6] <<  6);   */
    aux = t[5] >> 7;
    aux = __or_lsl_inplace(aux, t[6], 6);
    r[j] = aux; j += 1;  // j = 10

    /* r[13 * i + 10]  =  (uint8_t) (t[6] >>  2);  */
    aux = t[6] >> 2;
    r[j] = aux; j += 1;  // j = 11

    /* r[13 * i + 11]  =  (uint8_t) (t[6] >> 10);  */
    /* r[13 * i + 11] |=  (uint8_t) (t[7] <<  3);  */
    t7 = a[i]; i += 1;
    t7 = __imm_sub_reg((1 << (D - 1)), t7);

    aux = t[6] >> 10;
    aux = __or_lsl_inplace(aux, t7, 3);
    r[j] = aux; j += 1; // j = 12

    /* r[13 * i + 12]  =  (uint8_t) (t[7] >>  5);  */
    aux = t7 >> 5;
    r[j] = aux; j += 1;  // j = 13
  }
  return r;
}

fn _t0_unpack_coefficient_at_index(
    reg ptr u8[POLYT0_PACKEDBYTES] packed,
    reg u32 index
) -> reg u32 {
    reg u32 coeff temp;
    reg u32 offset;
    reg u32 start_byte;

    // 8 coefficients are packed in 13 bytes
    start_byte = (index >> 3);
    temp = 13;
    start_byte *= temp;

    offset = index & 0x7;

    if (offset == 0)
    {
        coeff = (32u)packed[start_byte];

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 8;

        coeff |= temp;
    }
    else if (offset == 1)
    {
        start_byte += 1;
        coeff = (32u)packed[start_byte];
        coeff >>= 5;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 3;
        coeff |= temp;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 11;
        coeff |= temp;
    }
    else if (offset == 2)
    {
        start_byte += 3;
        coeff = (32u)packed[start_byte];
        coeff >>= 2;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 6;

        coeff |= temp;
    }
    else if (offset == 3)
    {
        start_byte += 4;
        coeff = (32u)packed[start_byte];
        coeff >>= 7;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 1;
        coeff |= temp;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 9;
        coeff |= temp;
    }
    else if (offset == 4)
    {
        start_byte += 6;
        coeff = (32u)packed[start_byte];
        coeff >>= 4;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 4;
        coeff |= temp;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 12;
        coeff |= temp;
    }
    else if (offset == 5)
    {
        start_byte += 8;
        coeff = (32u)packed[start_byte];
        coeff >>= 1;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 7;
        coeff |= temp;
    }
    else if (offset == 6)
    {
        start_byte += 9;
        coeff = (32u)packed[start_byte];
        coeff >>= 6;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 2;
        coeff |= temp;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 10;
        coeff |= temp;
    }
    else
    {
        start_byte += 11;
        coeff = (32u)packed[start_byte];
        coeff >>= 3;

        start_byte += 1;
        temp = (32u)packed[start_byte];
        temp <<= 5;
        coeff |= temp;
    }

    temp = 0x1FFF;
    coeff &= temp;

    temp = 1 << (D - 1);
    coeff = temp - coeff;

    return coeff;
}
