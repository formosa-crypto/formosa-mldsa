inline fn __pack_s1_element_in_signing_key(
    reg ptr u8[SIGNING_KEY_SIZE] signing_key,
    reg ptr u32[N] s1_element,
    inline int INDEX
) -> reg ptr u8[SIGNING_KEY_SIZE]
{
    inline int START_OF_S1_PACKED = (2 * SEEDBYTES) + VERIFICATION_KEY_HASH_SIZE;
    inline int STARTING_INDEX = START_OF_S1_PACKED + (INDEX * POLYETA_PACKEDBYTES);

    signing_key[STARTING_INDEX : POLYETA_PACKEDBYTES] =
        _polyeta_pack(
            signing_key[STARTING_INDEX : POLYETA_PACKEDBYTES],
            s1_element
        );

    return signing_key;
}

inline fn __pack_s2_element_in_signing_key(
    reg ptr u8[SIGNING_KEY_SIZE] signing_key,
    reg ptr u32[N] s2_element,
    inline int INDEX
) -> reg ptr u8[SIGNING_KEY_SIZE]
{
    inline int START_OF_S2_PACKED = (2 * SEEDBYTES) + VERIFICATION_KEY_HASH_SIZE + (L * POLYETA_PACKEDBYTES);
    inline int STARTING_INDEX = START_OF_S2_PACKED + (INDEX * POLYETA_PACKEDBYTES);

    signing_key[STARTING_INDEX : POLYETA_PACKEDBYTES] =
        _polyeta_pack(
            signing_key[STARTING_INDEX : POLYETA_PACKEDBYTES],
            s2_element
        );

    return signing_key;
}

inline fn __pack_t0_element_in_signing_key(
    reg ptr u8[SIGNING_KEY_SIZE] signing_key,
    reg ptr u32[N] t0_element,
    inline int INDEX
) -> reg ptr u8[SIGNING_KEY_SIZE]
{
    inline int START_OF_T0_PACKED = (2 * SEEDBYTES) + VERIFICATION_KEY_HASH_SIZE + ((K + L) * POLYETA_PACKEDBYTES);
    inline int STARTING_INDEX = START_OF_T0_PACKED + (INDEX * POLYT0_PACKEDBYTES);

    signing_key[STARTING_INDEX : POLYT0_PACKEDBYTES] =
        _polyt0_pack(
            signing_key[STARTING_INDEX : POLYT0_PACKEDBYTES],
            t0_element
        );

    return signing_key;
}

/*************************************************
 * Name:        JASMIN_MLDSA_unpack_sk
 *
 * Description: Unpack secret key sk = (rho, tr, key, t0, s1, s2).
 *
 * Arguments:   - const uint8_t rho[]: output byte array for rho
 *              - const uint8_t tr[]: output byte array for tr
 *              - const uint8_t key[]: output byte array for key
 *              - const polyveck *t0: pointer to output vector t0
 *              - const polyvecl *s1: pointer to output vector s1
 *              - const polyveck *s2: pointer to output vector s2
 *              - uint8_t sk[]: byte array containing bit-packed sk
 **************************************************/
fn _unpack_sk(
    reg ptr u8[SEEDBYTES] key,
    reg ptr u32[polyvecl] s1,
    reg ptr u32[polyveck] s2,
    #secret reg ptr u8[SIGNING_KEY_SIZE] sk
) -> reg ptr u8[SEEDBYTES],
     reg ptr u32[polyvecl],
     reg ptr u32[polyveck]
{
    sk = sk; s1 = s1; s2 = s2;

    inline int i;
    inline int current_position;

    reg ptr u8[SEEDBYTES] tsk;

    current_position = SEEDBYTES;

    tsk = sk[current_position :  SEEDBYTES];
    key = #copy(tsk);
    current_position += SEEDBYTES;

    current_position += VERIFICATION_KEY_HASH_SIZE;

    reg ptr u8[POLYETA_PACKEDBYTES] nsk;

    () = #spill(s2);
    () = #spill(key);
    reg ptr u32[N] ns1;
    for i = 0 to L {
        ns1 = s1[i * N: N];
        nsk = sk[current_position : POLYETA_PACKEDBYTES];
        s1[i * N: N] = _polyeta_unpack(ns1, nsk);
        current_position += POLYETA_PACKEDBYTES;
    }

    () = #unspill(s2);
    reg ptr u32[N] ns2;
    for i = 0 to K {
        ns2 = s2[i * N: N];
        nsk = sk[current_position : POLYETA_PACKEDBYTES];
        () = #spill(sk);
        s2[i * N: N] = _polyeta_unpack(ns2, nsk);
        () = #unspill(sk);
        current_position += POLYETA_PACKEDBYTES;
    }

    return key, s1, s2;
}
