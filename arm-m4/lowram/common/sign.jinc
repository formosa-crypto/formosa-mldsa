inline fn __copy_polyvecl(reg ptr u32[polyvecl] s1hat, reg ptr u32[polyvecl] s1) -> reg ptr u32[polyvecl] {
    reg u32 i, t;

    i = 0;
    while (i < polyvecl) {
      t = s1[i];
      s1hat[i] = t;
      i += 1;
    }
    return s1hat;
}

/************************************************
 * Name:        crypto_sign_signature_ctx_seed
 *
 * Description: Computes signature.
 *
 * Arguments:   - uint8_t *sig:   pointer to output signature (of length PQCLEAN_MLDSA_CLEAN_CRYPTO_BYTES)
 *              - size_t *siglen: pointer to output length of signature
 *              - uint8_t *m:     pointer to message to be signed
 *              - size_t mlen:    length of message
 *              - uint8_t *ctx:   pointer to context string
 *              - size_t ctxlen:  length of context string
 *              - uint8_t *sk:    pointer to bit-packed secret key
 *              - uint8_t *rand:  pointer to randomness (of length RNDBYTES)
 *
 * Returns 0 (success) or -1 (context string too long)
 **************************************************/
inline fn __sign_internal(
    #public reg ptr u8[SIGNATURE_SIZE] sig,
    reg ptr u32[3] ctx_m_rand,
    reg ptr u32[2] ctxlen_mlen,
    #secret reg ptr u8[SIGNING_KEY_SIZE] signing_key
) -> #public reg ptr u8[SIGNATURE_SIZE], reg u32
{
    sig = sig;

    reg u32 status;
    stack u32[polyveck] s_s2;
    stack u32[polyvecl] s_s1;
    stack u8[SEEDBYTES + RNDBYTES + CRHBYTES] s_key_rnd_mu;
    stack u32[25*2] state;

    reg ptr u8[SEEDBYTES] key;
    reg ptr u8[COMMITMENT_HASH_SIZE] commitment_hash;

    stack u8[CRHBYTES] rhoprime;
    reg ptr u8[CRHBYTES] rhoprime_ptr;

    reg ptr u32[polyveck] s2;
    reg ptr u32[polyvecl] s1;
    reg ptr u8[RNDBYTES] rnd;
    reg ptr u8[CRHBYTES] mu;
    reg ptr u8[SEEDBYTES + RNDBYTES + CRHBYTES] key_rnd_mu;
    reg ptr u8[2] mu2;
    reg ptr u32[25*2] pstate;

    stack u32[polyvecl] mask, signer_response;

    stack u32[polyveck] hint_vector;
    reg ptr u32[polyveck] h;
    reg ptr u32[N] hint_polynomial_ptr;

    stack u32[polyveck] w1 s_w0;
    reg ptr u32[polyveck] w1_pointer w0;

    stack u32[N] challenge;
    reg ptr u32[N] challenge_ptr;

    stack u32[N] polynomial element_of_A;

    reg u32 pos m mlen ctx ctxlen t;

    reg u32 continue nonce nonce_for_mask;
    reg ptr u8[K * POLYW1_PACKEDBYTES] sig1;

    inline int i;
    inline int row_number column_number;

    status = -1;

    ctxlen = ctxlen_mlen[0];

    if (ctxlen <= 255) {
        () = #spill(ctx_m_rand);

        key = s_key_rnd_mu[0:SEEDBYTES];
        s1 = s_s1;
        s2 = s_s2;

        () = #spill(sig, status, ctxlen, ctxlen_mlen);
        (key, s1, s2) = _unpack_sk(key, s1, s2, signing_key);
        s_s1 = s1;
        s_s2 = s2;
        s_key_rnd_mu[0:SEEDBYTES] = key;

        () = #spill(signing_key);

        mu2 = s_key_rnd_mu[SEEDBYTES + RNDBYTES : 2];
        t = 0;
        mu2[0] = (8u)t;

        () = #unspill(ctxlen_mlen);
        t = ctxlen_mlen[0];
        () = #spill(ctxlen_mlen);

        mu2[1] = (8u)t;
        s_key_rnd_mu[SEEDBYTES + RNDBYTES : 2] = mu2;

        pstate = state;
        // VERIFICATION_KEY_HASH_SIZE (64) + 2 < SHAKE256_RATE (136)
        () = #unspill(signing_key);
        pstate = __add_crh(pstate, signing_key[2 * SEEDBYTES : VERIFICATION_KEY_HASH_SIZE]); // VERIFICATION_KEY_HASH_SIZE = CRHBYTES

        () = #unspill(ctxlen_mlen);
        t = ctxlen_mlen[0];
        () = #spill(ctxlen_mlen);
        pstate = __add_message_prefix(pstate, t, VERIFICATION_KEY_HASH_SIZE);
        pstate = __add_zero_after_add_naive(pstate, VERIFICATION_KEY_HASH_SIZE + 2);
        pos = VERIFICATION_KEY_HASH_SIZE + 2;

        () = #unspill(ctx_m_rand);
        ctx = ctx_m_rand[0];
        () = #spill(ctx_m_rand);

        () = #unspill(ctxlen);
        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, ctx, ctxlen);

        () = #unspill(ctxlen_mlen);
        mlen = ctxlen_mlen[1];

        () = #unspill(ctx_m_rand);
        m = ctx_m_rand[1];
        () = #spill(ctx_m_rand);

        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, m, mlen);
        pstate = _shake256_add_block_end(pstate, pos);
        pstate = _keccakf1600_ref(pstate);

        mu = s_key_rnd_mu[SEEDBYTES + RNDBYTES : CRHBYTES];
        mu = #copy(pstate.[:u8 0 : CRHBYTES]);
        s_key_rnd_mu[SEEDBYTES + RNDBYTES : CRHBYTES] = mu;

        rnd = s_key_rnd_mu[SEEDBYTES : RNDBYTES];
        () = #unspill(ctx_m_rand);
        reg u32 rand = ctx_m_rand[2];
        for i = 0 to RNDBYTES/4 {
            t = [:u32 rand + 4*i];
            rnd[:u32 i] = t;
        }
        s_key_rnd_mu[SEEDBYTES : RNDBYTES] = rnd;

        key_rnd_mu = s_key_rnd_mu;
        pstate = __add_seedrndcrh_ref(pstate, key_rnd_mu);
        pstate = __add_zero_after_add(pstate, SEEDBYTES + RNDBYTES + CRHBYTES);
        pstate = __add_block_end(pstate, SEEDBYTES + RNDBYTES + CRHBYTES, SHAKE256_RATE);
        pstate = _keccakf1600_ref(pstate);
        state = pstate;

        rhoprime_ptr = rhoprime;
        rhoprime_ptr = #copy(pstate.[:u8 0 : CRHBYTES]);
        rhoprime = rhoprime_ptr;

        s1 = s_s1; s1 = _polyvecl_ntt(s1); s_s1 = s1;
        s2 = s_s2; s2 = _polyveck_ntt(s2); s_s2 = s2;

        nonce_for_mask = 0;
        () = #spill(nonce_for_mask);
        while {
            /* Sample intermediate vector y */
            rhoprime_ptr = rhoprime;
            () = #unspill(nonce_for_mask);
            mask, nonce_for_mask = _polyvecl_uniform_gamma1(mask, nonce_for_mask, rhoprime_ptr);
            () = #spill(nonce_for_mask);

            /* Set w = Ay */
            signer_response = __copy_polyvecl(signer_response, mask);
            signer_response = _polyvecl_ntt(signer_response);

            for row_number = 0 to K {
                pstate = state;
                nonce = __or_lsl(0, row_number, 8);
                () = #unspill(signing_key);
                pstate = _init_xof_for_element_of_A(pstate, signing_key[0 : SEEDBYTES], nonce);
                element_of_A, pstate = _poly_uniform_(element_of_A, pstate);
                state = pstate;

                w1[row_number * N : N] = _poly_pointwise_montgomery(w1[row_number * N : N], element_of_A, signer_response[0 : N]);

                for column_number = 1 to L {
                    pstate = state;
                    nonce = __or_lsl(column_number, row_number, 8);
                    () = #unspill(signing_key);
                    pstate = _init_xof_for_element_of_A(pstate, signing_key[0 : SEEDBYTES], nonce);
                    element_of_A, pstate = _poly_uniform_(element_of_A, pstate);
                    state = pstate;

                    polynomial = _poly_pointwise_montgomery(polynomial, element_of_A, signer_response[column_number * N : N]);

                    w1[row_number * N : N] = _poly_add_inplace(w1[row_number * N : N], polynomial);
                }
            }

            w1_pointer = w1;
            w1_pointer = _polyveck_reduce(w1_pointer);
            w1_pointer = _polyveck_invntt_tomont(w1_pointer);

            /* Decompose w and call the random oracle */
            w1_pointer = _polyveck_caddq(w1_pointer);
            w0 = s_w0;
            w1_pointer, s_w0 = _polyveck_decompose_inplace(w1_pointer, w0);
            w1 = w1_pointer;
            () = #unspill(sig);
            sig1 = sig[0: K * POLYW1_PACKEDBYTES];
            sig1 = _polyveck_pack_w1(sig1, w1_pointer);
            sig[0: K * POLYW1_PACKEDBYTES] = sig1;
            () = #spill(sig);
            // SHAKE256
            pstate = state; mu = s_key_rnd_mu[SEEDBYTES + RNDBYTES : CRHBYTES];
            pstate = __add_crh(pstate, mu);
            pstate = __add_zero_after_add(pstate, CRHBYTES);
            pstate, pos = __derive_commitment_hash(pstate, CRHBYTES, sig1);
            pstate = _shake256_add_block_end(pstate, pos);
            pstate = _keccakf1600_ref(pstate);

            () = #unspill(sig);
            commitment_hash = sig[0:COMMITMENT_HASH_SIZE];
            commitment_hash = #copy(pstate.[:u8 0 : COMMITMENT_HASH_SIZE]);
            sig[0:COMMITMENT_HASH_SIZE] = commitment_hash;

            state = pstate;

            () = #spill(sig);
            challenge_ptr = challenge;

            #declassify commitment_hash = commitment_hash;
            state, challenge_ptr = _poly_challenge(state, challenge_ptr, commitment_hash);
            challenge_ptr = _poly_ntt(challenge_ptr);
            /* Compute z, reject if it reveals secret */
            s1 = s_s1;
            signer_response = _polyvecl_pointwise_poly_montgomery(signer_response, challenge_ptr, s1); challenge = challenge_ptr;
            signer_response = _polyvecl_invntt_tomont(signer_response);
            signer_response = _polyvecl_add_inplace(signer_response, mask);
            signer_response = _polyvecl_reduce(signer_response);

            reg u32 check_norm bound;
            bound = iGAMMA1 - BETA;
            check_norm = _polyvecl_check_norm(signer_response, bound);
            () = #spill(sig);
            if (check_norm != 0) {
                continue = 1;
            } else {
                s2 = s_s2;

                h = hint_vector;
                h = _polyveck_pointwise_poly_montgomery(h, challenge_ptr, s2);
                h = _polyveck_invntt_tomont(h);
                hint_vector = h;

                w0 = s_w0;
                w0 = _polyveck_sub_inplace(w0, h);
                w0 = _polyveck_reduce(w0);
                s_w0 = w0;
                bound = iGAMMA2 - BETA;
                check_norm = _polyveck_check_norm(w0, bound);

                if (check_norm != 0) {
                    continue = 1;
                } else {
                    challenge_ptr = challenge;

                    for row_number = 0 to K {
                        hint_polynomial_ptr = hint_vector[row_number * N : N];

                        () = #unspill(signing_key);
                        polynomial = _polyt0_unpack(polynomial, signing_key[START_OF_T0_IN_SIGNING_KEY + (row_number * POLYT0_PACKEDBYTES) : POLYT0_PACKEDBYTES]);
                        polynomial = _poly_ntt(polynomial);

                        hint_polynomial_ptr = _poly_pointwise_montgomery(hint_polynomial_ptr, polynomial, challenge_ptr);
                        hint_polynomial_ptr = _poly_invntt_tomont(hint_polynomial_ptr);
                        hint_polynomial_ptr = _poly_reduce(hint_polynomial_ptr);
                        hint_vector[row_number * N : N] = hint_polynomial_ptr;
                    }

                    bound = iGAMMA2;

                    h = hint_vector;
                    check_norm = _polyveck_check_norm(h, bound);
                    if (check_norm != 0) {
                        continue = 1;
                    } else {
                        w0 = s_w0;
                        w0 = _polyveck_add_inplace(w0, h);
                        s_w0 = w0; w1_pointer = w1;
                        reg u32 n;

                        h = hint_vector;
                        n, h = _polyveck_make_hint(h, w0, w1_pointer);
                        hint_vector = h;

                        if (n > MAX_ONES_IN_HINT) {
                            continue = 1;
                        } else {
                            () = #unspill(sig);

                            #declassify h = hint_vector;
                            #declassify signer_response = signer_response;
                            #declassify sig = sig;

                            sig = _pack_sig_nocopy(sig, signer_response, h);
                            () = #spill(sig);
                            continue = 0;
                        }
                    }
                }
            }
        } (continue == 1)
        status = 0;
        () = #unspill(sig);
    }

    #declassify sig = sig;
    return sig, status;
}
