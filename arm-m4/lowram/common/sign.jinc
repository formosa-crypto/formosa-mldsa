inline fn __copy_polyvecl(reg ptr u32[polyvecl] s1hat, reg ptr u32[polyvecl] s1) -> reg ptr u32[polyvecl] {
    reg u32 i, t;

    i = 0;
    while (i < polyvecl) {
      t = s1[i];
      s1hat[i] = t;
      i += 1;
    }
    return s1hat;
}

/************************************************
 * Name:        crypto_sign_signature_ctx_seed
 *
 * Description: Computes signature.
 *
 * Arguments:   - uint8_t *sig:   pointer to output signature (of length PQCLEAN_MLDSA_CLEAN_CRYPTO_BYTES)
 *              - size_t *siglen: pointer to output length of signature
 *              - uint8_t *m:     pointer to message to be signed
 *              - size_t mlen:    length of message
 *              - uint8_t *ctx:   pointer to context string
 *              - size_t ctxlen:  length of context string
 *              - uint8_t *sk:    pointer to bit-packed secret key
 *              - uint8_t *rand:  pointer to randomness (of length RNDBYTES)
 *
 * Returns 0 (success) or -1 (context string too long)
 **************************************************/
inline fn __sign_internal(
    #public reg ptr u8[SIGNATURE_SIZE] sig,
    reg ptr u32[3] ctx_m_rand,
    reg ptr u32[2] ctxlen_mlen,
    #secret reg ptr u8[SIGNING_KEY_SIZE] signing_key
) -> #public reg ptr u8[SIGNATURE_SIZE], reg u32
{
    sig = sig;

    reg u32 status;
    stack u8[CRHBYTES] message_rep;

    stack u32[25*2] state;
    reg ptr u32[25*2] pstate;

    reg ptr u8[COMMITMENT_HASH_SIZE] commitment_hash;

    stack u8[CRHBYTES] rhoprime;
    reg ptr u8[CRHBYTES] rhoprime_ptr;

    reg ptr u8[RNDBYTES] rnd;
    reg ptr u8[CRHBYTES] message_rep_ptr;

    stack u32[polyvecl] mask;
    reg ptr u32[polyvecl] mask_ptr;

    stack u32[N] mask_element;
    reg ptr u32[N] mask_element_ptr;

    stack u32[N] signer_response_elem_ptr;
    reg ptr u8[POLYZ_PACKEDBYTES] packed_signer_response_elem;

    stack u32[polyveck] hint_vector;
    reg ptr u32[polyveck] h;
    reg ptr u32[N] hint_polynomial_ptr;

    stack u32[polyveck] w1 s_w0;
    reg ptr u32[polyveck] w1_pointer w0;

    stack u32[N] challenge;
    reg ptr u32[N] challenge_ptr;

    stack u32[N] polynomial element_of_A;

    reg u32 pos m mlen ctx ctxlen t;

    reg u32 continue nonce nonce_for_mask;
    reg u32 check_norm bound;
    reg u32 randomness_ptr idx;

    reg ptr u8[K * POLYW1_PACKEDBYTES] w1_packed_in_sig;

    inline int i;
    inline int row_number column_number;

    status = -1;

    ctxlen = ctxlen_mlen[0];

    if (ctxlen <= 255) {
        () = #spill(ctx_m_rand, sig, status, ctxlen, ctxlen_mlen, signing_key);

        pstate = state;

        () = #unspill(signing_key);
        pstate = __add_crh(pstate, signing_key[2 * SEEDBYTES : VERIFICATION_KEY_HASH_SIZE]); // VERIFICATION_KEY_HASH_SIZE = CRHBYTES

        () = #unspill(ctxlen_mlen);
        t = ctxlen_mlen[0];

        pstate = __add_message_prefix(pstate, t, VERIFICATION_KEY_HASH_SIZE);
        pstate = __add_zero_after_add_naive(pstate, VERIFICATION_KEY_HASH_SIZE + 2);
        pos = VERIFICATION_KEY_HASH_SIZE + 2;

        () = #unspill(ctx_m_rand);
        ctx = ctx_m_rand[0];

        () = #unspill(ctxlen);
        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, ctx, ctxlen);

        () = #unspill(ctxlen_mlen);
        mlen = ctxlen_mlen[1];

        () = #unspill(ctx_m_rand);
        m = ctx_m_rand[1];

        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, m, mlen);
        pstate = _shake256_add_block_end(pstate, pos);
        pstate = _keccakf1600_ref(pstate);

        message_rep = #copy(pstate.[:u8 0 : CRHBYTES]);
        state = pstate;

        // Prepare state for obtaining rhoprime
        () = #unspill(signing_key);
        state.[:u8 0 : SEEDBYTES] = #copy(signing_key[SEEDBYTES : SEEDBYTES]);

        rnd = state.[:u8 SEEDBYTES : RNDBYTES];
        () = #unspill(ctx_m_rand);
        randomness_ptr = ctx_m_rand[2];
        for i = 0 to RNDBYTES/4 {
            t = [:u32 randomness_ptr + 4*i];
            rnd[:u32 i] = t;
        }
        state.[:u8 SEEDBYTES : RNDBYTES] = rnd;

        message_rep_ptr = state.[:u8 SEEDBYTES + RNDBYTES : CRHBYTES];
        message_rep_ptr = #copy(message_rep);
        state.[:u8 SEEDBYTES + RNDBYTES : CRHBYTES] = message_rep_ptr;

        pstate = state;
        pstate = __add_zero_after_add(pstate, SEEDBYTES + RNDBYTES + CRHBYTES);
        pstate = __add_block_end(pstate, SEEDBYTES + RNDBYTES + CRHBYTES, SHAKE256_RATE);
        pstate = _keccakf1600_ref(pstate);
        state = pstate;

        rhoprime_ptr = rhoprime;
        rhoprime_ptr = #copy(pstate.[:u8 0 : CRHBYTES]);
        rhoprime = rhoprime_ptr;

        nonce_for_mask = 0;
        () = #spill(nonce_for_mask);
        while {
            /* Sample intermediate vector y */
            rhoprime_ptr = rhoprime;
            () = #unspill(nonce_for_mask);
            mask, nonce_for_mask = _polyvecl_uniform_gamma1(mask, nonce_for_mask, rhoprime_ptr);
            () = #spill(nonce_for_mask);

            for row_number = 0 to K {
                pstate = state;
                nonce = __or_lsl(0, row_number, 8);
                () = #unspill(signing_key);
                pstate = _init_xof_for_element_of_A(pstate, signing_key[0 : SEEDBYTES], nonce);
                element_of_A, pstate = _poly_uniform(element_of_A, pstate);
                state = pstate;

                // We need mask[0 : N]
                mask_ptr = mask;
                mask_element_ptr = mask_element;
                idx = 0;
                while (idx < N) {
                    t = mask_ptr[idx];
                    mask_element_ptr[idx] = t;

                    idx += 1;
                }
                mask_element = mask_element_ptr;

                mask_element = _poly_ntt(mask_element);
                w1[row_number * N : N] = _poly_pointwise_montgomery(w1[row_number * N : N], element_of_A, mask_element);

                for column_number = 1 to L {
                    pstate = state;
                    nonce = __or_lsl(column_number, row_number, 8);
                    () = #unspill(signing_key);
                    pstate = _init_xof_for_element_of_A(pstate, signing_key[0 : SEEDBYTES], nonce);
                    element_of_A, pstate = _poly_uniform(element_of_A, pstate);
                    state = pstate;

                    // We need mask[column_number * N : N]

                    mask_ptr = mask;
                    mask_element_ptr = mask_element;
                    idx = 0;
                    while (idx < N) {
                        t = N * column_number;
                        t += idx;

                        t = mask_ptr[t];
                        mask_element_ptr[idx] = t;

                        idx += 1;
                    }
                    mask_element = mask_element_ptr;

                    mask_element = _poly_ntt(mask_element);
                    polynomial = _poly_pointwise_montgomery(polynomial, element_of_A, mask_element);

                    w1[row_number * N : N] = _poly_add_inplace(w1[row_number * N : N], polynomial);
                }
            }

            w1_pointer = w1;
            w1_pointer = _polyveck_reduce(w1_pointer);
            w1_pointer = _polyveck_invntt_tomont(w1_pointer);

            /* Decompose w and call the random oracle */
            w1_pointer = _polyveck_caddq(w1_pointer);
            w0 = s_w0;
            w1_pointer, s_w0 = _polyveck_decompose_inplace(w1_pointer, w0);
            w1 = w1_pointer;
            () = #unspill(sig);
            w1_packed_in_sig = sig[0: K * POLYW1_PACKEDBYTES];
            w1_packed_in_sig = _polyveck_pack_w1(w1_packed_in_sig, w1_pointer);
            sig[0: K * POLYW1_PACKEDBYTES] = w1_packed_in_sig;
            () = #spill(sig);
            // SHAKE256
            pstate = state;
            pstate = __add_crh(pstate, message_rep);
            pstate = __add_zero_after_add(pstate, CRHBYTES);
            pstate, pos = __derive_commitment_hash(pstate, CRHBYTES, w1_packed_in_sig);
            pstate = _shake256_add_block_end(pstate, pos);
            pstate = _keccakf1600_ref(pstate);

            () = #unspill(sig);
            commitment_hash = sig[0:COMMITMENT_HASH_SIZE];
            commitment_hash = #copy(pstate.[:u8 0 : COMMITMENT_HASH_SIZE]);
            sig[0:COMMITMENT_HASH_SIZE] = commitment_hash;

            state = pstate;

            () = #spill(sig);
            challenge_ptr = challenge;
            #declassify commitment_hash = commitment_hash;
            state, challenge_ptr = _poly_challenge(state, challenge_ptr, commitment_hash);
            challenge_ptr = _poly_ntt(challenge_ptr);
            challenge = challenge_ptr;

            () = #spill(challenge_ptr);

            check_norm = 0;
            /* Compute z, reject if it reveals secret */
            for column_number = 0 to L {
                if (check_norm == 0) {
                    () = #unspill(signing_key);
                    polynomial = _polyeta_unpack(polynomial, signing_key[START_OF_S1_IN_SIGNING_KEY + (column_number * POLYETA_PACKEDBYTES) : POLYETA_PACKEDBYTES]);
                    polynomial = _poly_ntt(polynomial);

                    () = #unspill(challenge_ptr);
                    signer_response_elem_ptr = _poly_pointwise_montgomery(signer_response_elem_ptr, challenge_ptr, polynomial);
                    signer_response_elem_ptr = _poly_invntt_tomont(signer_response_elem_ptr);

                    signer_response_elem_ptr = _poly_add_inplace(signer_response_elem_ptr, mask[column_number * N : N]);
                    signer_response_elem_ptr = _poly_reduce(signer_response_elem_ptr);

                    bound = iGAMMA1 - BETA;
                    check_norm = _poly_check_norm(signer_response_elem_ptr, bound);
                    if (check_norm == 0) {
                        () = #unspill(sig);
                        packed_signer_response_elem = sig[COMMITMENT_HASH_SIZE + (column_number * POLYZ_PACKEDBYTES) : POLYZ_PACKEDBYTES];
                        packed_signer_response_elem = _polyz_pack(packed_signer_response_elem, signer_response_elem_ptr);
                        sig[COMMITMENT_HASH_SIZE + (column_number * POLYZ_PACKEDBYTES) : POLYZ_PACKEDBYTES] = packed_signer_response_elem;
                        () = #spill(sig);
                    }
                }
            }

            if (check_norm != 0) {
                continue = 1;
            } else {
                for row_number = 0 to K {
                    hint_polynomial_ptr = hint_vector[row_number * N : N];

                    () = #unspill(signing_key);
                    polynomial = _polyeta_unpack(polynomial, signing_key[START_OF_S2_IN_SIGNING_KEY + (row_number * POLYETA_PACKEDBYTES) : POLYETA_PACKEDBYTES]);
                    polynomial = _poly_ntt(polynomial);

                    () = #unspill(challenge_ptr);
                    hint_polynomial_ptr = _poly_pointwise_montgomery(hint_polynomial_ptr, polynomial, challenge_ptr);
                    hint_polynomial_ptr = _poly_invntt_tomont(hint_polynomial_ptr);
                    hint_vector[row_number * N : N] = hint_polynomial_ptr;
                }

                h = hint_vector;
                w0 = s_w0;
                w0 = _polyveck_sub_inplace(w0, h);
                w0 = _polyveck_reduce(w0);
                s_w0 = w0;
                bound = iGAMMA2 - BETA;
                check_norm = _polyveck_check_norm(w0, bound);

                if (check_norm != 0) {
                    continue = 1;
                } else {
                    for row_number = 0 to K {
                        hint_polynomial_ptr = hint_vector[row_number * N : N];

                        () = #unspill(signing_key);
                        polynomial = _polyt0_unpack(polynomial, signing_key[START_OF_T0_IN_SIGNING_KEY + (row_number * POLYT0_PACKEDBYTES) : POLYT0_PACKEDBYTES]);
                        polynomial = _poly_ntt(polynomial);

                        () = #unspill(challenge_ptr);
                        hint_polynomial_ptr = _poly_pointwise_montgomery(hint_polynomial_ptr, polynomial, challenge_ptr);
                        hint_polynomial_ptr = _poly_invntt_tomont(hint_polynomial_ptr);
                        hint_polynomial_ptr = _poly_reduce(hint_polynomial_ptr);
                        hint_vector[row_number * N : N] = hint_polynomial_ptr;
                    }

                    bound = iGAMMA2;

                    h = hint_vector;
                    check_norm = _polyveck_check_norm(h, bound);
                    if (check_norm != 0) {
                        continue = 1;
                    } else {
                        w0 = s_w0;
                        w0 = _polyveck_add_inplace(w0, h);
                        s_w0 = w0; w1_pointer = w1;
                        reg u32 n;

                        h = hint_vector;
                        n, h = _polyveck_make_hint(h, w0, w1_pointer);
                        hint_vector = h;

                        if (n > MAX_ONES_IN_HINT) {
                            continue = 1;
                        } else {
                            () = #unspill(sig);

                            #declassify h = hint_vector;
                            #declassify sig = sig;

                            sig = _pack_sig_nocopy(sig, h);
                            () = #spill(sig);
                            continue = 0;
                        }
                    }
                }
            }
        } (continue == 1)
        status = 0;
        () = #unspill(sig);
    }

    #declassify sig = sig;
    return sig, status;
}
