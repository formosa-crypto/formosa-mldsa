inline fn __sign_internal(
    #public reg ptr u8[SIGNATURE_SIZE] sig,
    reg ptr u32[3] ctx_m_rand,
    reg ptr u32[2] ctxlen_mlen,
    #secret reg ptr u8[SIGNING_KEY_SIZE] signing_key
) -> #public reg ptr u8[SIGNATURE_SIZE], reg u32
{
    sig = sig;

    stack u8[CRHBYTES] message_rep;
    reg ptr u8[CRHBYTES] message_rep_ptr;

    stack u8[CRHBYTES] rhoprime;
    reg ptr u8[CRHBYTES] rhoprime_ptr;

    stack u32[25*2] state;
    reg ptr u32[25*2] pstate;

    reg ptr u8[COMMITMENT_HASH_SIZE] commitment_hash;

    reg ptr u8[RNDBYTES] rnd;

    stack u32[N] signer_response_elem;
    reg ptr u8[POLYZ_PACKEDBYTES] packed_signer_response_elem;

    stack u8[K * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] w_compressed;

    stack u32[N] challenge;
    stack u8[COMPRESSED_CHALLENGE_SIZE] compressed_challenge;

    stack u32[N] polynomial;

    reg u32 status;
    reg u32 pos m mlen ctx ctxlen t;
    reg u32 continue nonce;
    reg u32 check_norm bound;
    reg u32 randomness_ptr idx;
    reg u32 hints total_hints;
    reg u32 hints_written;
    reg u32 row_number_reg;
    reg u32 iteration_number;

    inline int i;
    inline int row_number column_number;

    status = -1;

    ctxlen = ctxlen_mlen[0];

    if (ctxlen <= 255) {
        () = #spill(ctx_m_rand, sig, status, ctxlen, ctxlen_mlen, signing_key);

        pstate = state;

        () = #unspill(signing_key);
        pstate = __add_crh(pstate, signing_key[2 * SEEDBYTES : VERIFICATION_KEY_HASH_SIZE]); // VERIFICATION_KEY_HASH_SIZE = CRHBYTES

        () = #unspill(ctxlen_mlen);
        t = ctxlen_mlen[0];

        pstate = __add_message_prefix(pstate, t, VERIFICATION_KEY_HASH_SIZE);
        pstate = __add_zero_after_add_naive(pstate, VERIFICATION_KEY_HASH_SIZE + 2);
        pos = VERIFICATION_KEY_HASH_SIZE + 2;

        () = #unspill(ctx_m_rand);
        ctx = ctx_m_rand[0];

        () = #unspill(ctxlen);
        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, ctx, ctxlen);

        () = #unspill(ctxlen_mlen);
        mlen = ctxlen_mlen[1];

        () = #unspill(ctx_m_rand);
        m = ctx_m_rand[1];

        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, m, mlen);
        pstate = _shake256_add_block_end(pstate, pos);
        pstate = _keccakf1600_ref(pstate);

        message_rep = #copy(pstate.[:u8 0 : CRHBYTES]);
        state = pstate;

        // Prepare state for obtaining rhoprime
        () = #unspill(signing_key);
        state.[:u8 0 : SEEDBYTES] = #copy(signing_key[SEEDBYTES : SEEDBYTES]);

        rnd = state.[:u8 SEEDBYTES : RNDBYTES];
        () = #unspill(ctx_m_rand);
        randomness_ptr = ctx_m_rand[2];
        for i = 0 to RNDBYTES/4 {
            t = [:u32 randomness_ptr + 4*i];
            rnd[:u32 i] = t;
        }
        state.[:u8 SEEDBYTES : RNDBYTES] = rnd;

        message_rep_ptr = state.[:u8 SEEDBYTES + RNDBYTES : CRHBYTES];
        message_rep_ptr = #copy(message_rep);
        state.[:u8 SEEDBYTES + RNDBYTES : CRHBYTES] = message_rep_ptr;

        pstate = state;
        pstate = __add_zero_after_add(pstate, SEEDBYTES + RNDBYTES + CRHBYTES);
        pstate = __add_block_end(pstate, SEEDBYTES + RNDBYTES + CRHBYTES, SHAKE256_RATE);
        pstate = _keccakf1600_ref(pstate);
        state = pstate;

        rhoprime_ptr = rhoprime;
        rhoprime_ptr = #copy(pstate.[:u8 0 : CRHBYTES]);
        rhoprime = rhoprime_ptr;

        iteration_number = -1;
        () = #spill(iteration_number);
        while {
            () = #unspill(iteration_number);
            iteration_number += 1;
            () = #spill(iteration_number);

            for row_number = 0 to K {
                w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] =
                    __zero_compressed_w_element(
                        w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING]);
            }

            for column_number = 0 to L {
                () = #unspill(iteration_number);
                nonce = L;
                nonce *= iteration_number;
                nonce += column_number;

                // Sample an element of the vector |mask|.
                polynomial = _poly_uniform_gamma1(polynomial, rhoprime, nonce);
                polynomial = _poly_ntt(polynomial);

                for row_number = 0 to K {
                    nonce = __or_lsl(column_number, row_number, 8);
                    () = #unspill(signing_key);
                    pstate = state;
                    w_compressed[row_number *
                                 COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING :
                                 COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING],
                    pstate =
                        _poly_compute_A_times_polynomial(
                            w_compressed[
                                row_number *
                                COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING :
                                COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING],
                            pstate,
                            signing_key[0 : SEEDBYTES],
                            nonce,
                            polynomial
                        );
                    state = pstate;
                }
            }

            for row_number = 0 to K {
                polynomial =
                    _poly_decompress_w1_element(
                        polynomial,
                        w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING]
                    );
                polynomial = _poly_invntt_tomont(polynomial);
                polynomial = _poly_caddq(polynomial);

                w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] =
                    _poly_compress_w1_element(
                        w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING],
                        polynomial
                    );

                polynomial = _poly_high_bits_inplace(polynomial);
                () = #unspill(sig);
                sig[row_number * POLYW1_PACKEDBYTES : POLYW1_PACKEDBYTES] =
                    _polyw1_pack(
                        sig[row_number * POLYW1_PACKEDBYTES : POLYW1_PACKEDBYTES],
                        polynomial
                    );
                () = #spill(sig);
            }

            // Generate the commitment hash
            pstate = state;
            pstate = __add_crh(pstate, message_rep);
            pstate = __add_zero_after_add(pstate, CRHBYTES);
            () = #unspill(sig);
            pstate, pos = __derive_commitment_hash(pstate, CRHBYTES, sig[0 : K * POLYW1_PACKEDBYTES]);
            pstate = _shake256_add_block_end(pstate, pos);
            pstate = _keccakf1600_ref(pstate);

            () = #unspill(sig);
            commitment_hash = sig[0:COMMITMENT_HASH_SIZE];
            commitment_hash = #copy(pstate.[:u8 0 : COMMITMENT_HASH_SIZE]);
            sig[0:COMMITMENT_HASH_SIZE] = commitment_hash;

            state = pstate;

            () = #spill(sig);
            #declassify commitment_hash = commitment_hash;
            state, challenge = _poly_generate_challenge(state, challenge, commitment_hash);
            compressed_challenge = _poly_compress_challenge(compressed_challenge, challenge);
            challenge = _poly_ntt(challenge);

            check_norm = 0;
            /* Compute z, reject if it reveals secret */
            for column_number = 0 to L {
                if (check_norm == 0) {
                    () = #unspill(signing_key);
                    polynomial = _poly_eta_unpack(polynomial, signing_key[START_OF_S1_IN_SIGNING_KEY + (column_number * POLYETA_PACKEDBYTES) : POLYETA_PACKEDBYTES]);
                    polynomial = _poly_ntt(polynomial);

                    signer_response_elem = _poly_pointwise_montgomery(signer_response_elem, challenge, polynomial);
                    signer_response_elem = _poly_invntt_tomont(signer_response_elem);

                    nonce = L;

                    () = #unspill(iteration_number);
                    nonce *= iteration_number;
                    nonce += column_number;
                    polynomial = _poly_uniform_gamma1(polynomial, rhoprime, nonce);

                    signer_response_elem = _poly_add_inplace(signer_response_elem, polynomial);
                    signer_response_elem = _poly_reduce(signer_response_elem);

                    bound = iGAMMA1 - BETA;
                    check_norm = _poly_check_norm(signer_response_elem, bound);
                    if (check_norm == 0) {
                        () = #unspill(sig);
                        packed_signer_response_elem = sig[COMMITMENT_HASH_SIZE + (column_number * POLYZ_PACKEDBYTES) : POLYZ_PACKEDBYTES];
                        packed_signer_response_elem = _polyz_pack(packed_signer_response_elem, signer_response_elem);
                        sig[COMMITMENT_HASH_SIZE + (column_number * POLYZ_PACKEDBYTES) : POLYZ_PACKEDBYTES] = packed_signer_response_elem;
                        () = #spill(sig);
                    }
                }
            }

            if (check_norm != 0) {
                continue = 1;
            } else {
                for row_number = 0 to K {
                    if (check_norm == 0) {
                        // Here, |polynomial| stands for |hint_element|
                        () = #unspill(signing_key);
                        polynomial = _poly_eta_unpack(polynomial, signing_key[START_OF_S2_IN_SIGNING_KEY + (row_number * POLYETA_PACKEDBYTES) : POLYETA_PACKEDBYTES]);
                        polynomial = _poly_ntt(polynomial);

                        polynomial = _poly_pointwise_montgomery_inplace(polynomial, challenge);
                        polynomial = _poly_invntt_tomont(polynomial);

                        polynomial =
                            _poly_subtract_from_compressed_w1_element(
                                polynomial,
                                w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING]
                            );

                        w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING] =
                            _poly_compress_w1_element(
                                w_compressed[row_number * COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING],
                                polynomial
                            );

                        polynomial = _poly_low_bits_inplace(polynomial);
                        polynomial = _poly_reduce(polynomial);

                        bound = iGAMMA2 - BETA;
                        check_norm = _poly_check_norm(polynomial, bound);
                    }
                }

                if (check_norm != 0) {
                    continue = 1;
                } else {
                    total_hints = 0;
                    hints_written = 0;
                    () = #spill(total_hints, hints_written);

                    for row_number = 0 to K {
                        if (check_norm == 0) {
                            // For what follows, |polynomial| stands in for
                            // |hint_element|
                            () = #unspill(signing_key);
                            polynomial = _poly_schoolbook_multiply_t0_by_challenge(
                                polynomial,
                                signing_key[START_OF_T0_IN_SIGNING_KEY + (row_number * POLYT0_PACKEDBYTES) : POLYT0_PACKEDBYTES],
                                compressed_challenge
                            );

                            bound = iGAMMA2;
                            check_norm = _poly_check_norm(polynomial, bound);
                            if (check_norm == 0) {
                                polynomial, hints = _poly_make_hint_inplace(polynomial, w_compressed[row_number *  COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING : COMPRESSED_W1_ELEMENT_SIZE_WITH_PADDING]);

                                () = #unspill(total_hints);
                                total_hints += hints;
                                () = #spill(total_hints);
                                if (total_hints <= MAX_ONES_IN_HINT) {
                                    () = #unspill(hints_written, sig);
                                    row_number_reg = row_number;
                                    sig[START_OF_HINT_IN_SIGNATURE : HINT_ENCODED_SIZE], hints_written = _pack_hint_element(
                                        sig[START_OF_HINT_IN_SIGNATURE : HINT_ENCODED_SIZE],
                                        polynomial,
                                        hints_written,
                                        row_number_reg
                                    );
                                    () = #spill(hints_written, sig);
                                }
                            }
                        }
                    }

                    () = #unspill(total_hints);
                    if (check_norm != 0) {
                        continue = 1;
                    } else if (total_hints > MAX_ONES_IN_HINT) {
                        continue = 1;
                    } else {
                        continue = 0;

                        // Finish writing out to the encoded hint by zeroing
                        // the rest of the elements.
                        idx = START_OF_HINT_IN_SIGNATURE;
                        () = #unspill(hints_written);
                        idx += hints_written;

                        () = #unspill(sig);
                        while (hints_written < MAX_ONES_IN_HINT) {
                            sig[idx] = continue;
                            idx += 1;

                            hints_written += 1;
                        }
                        () = #spill(sig);
                    }
                }
            }
        } (continue == 1)
        status = 0;
        () = #unspill(sig);
    }

    #declassify sig = sig;
    return sig, status;
}
