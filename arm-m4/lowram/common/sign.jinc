inline fn __copy_polyvecl(reg ptr u32[polyvecl] s1hat, reg ptr u32[polyvecl] s1) -> reg ptr u32[polyvecl] {
    reg u32 i, t;

    i = 0;
    while (i < polyvecl) {
      t = s1[i];
      s1hat[i] = t;
      i += 1;
    }
    return s1hat;
}

/************************************************
 * Name:        crypto_sign_signature_ctx_seed
 *
 * Description: Computes signature.
 *
 * Arguments:   - uint8_t *sig:   pointer to output signature (of length PQCLEAN_MLDSA_CLEAN_CRYPTO_BYTES)
 *              - size_t *siglen: pointer to output length of signature
 *              - uint8_t *m:     pointer to message to be signed
 *              - size_t mlen:    length of message
 *              - uint8_t *ctx:   pointer to context string
 *              - size_t ctxlen:  length of context string
 *              - uint8_t *sk:    pointer to bit-packed secret key
 *              - uint8_t *rand:  pointer to randomness (of length RNDBYTES)
 *
 * Returns 0 (success) or -1 (context string too long)
 **************************************************/
inline fn __sign_internal(
    #public reg ptr u8[SIGNATURE_SIZE] sig,
    reg ptr u32[3] ctx_m_rand,
    reg ptr u32[2] ctxlen_mlen,
    #secret reg ptr u8[SIGNING_KEY_SIZE] sk
) -> #public reg ptr u8[SIGNATURE_SIZE], reg u32
{
    sig = sig;

    reg u32 status;
    stack u8[SEEDBYTES] s_rho;
    stack u32[polyveck] s_t0, s_s2;
    stack u32[polyvecl] s_s1;
    stack u8[SEEDBYTES + RNDBYTES + CRHBYTES] s_key_rnd_mu;
    stack u32[25*2] state;

    reg ptr u8[SEEDBYTES] rho, key;
    reg ptr u8[COMMITMENT_HASH_SIZE] commitment_hash;

    stack u8[VERIFICATION_KEY_HASH_SIZE] verification_key_hash;

    stack u8[CRHBYTES] rhoprime;
    reg ptr u8[CRHBYTES] rhoprime_ptr;

    reg ptr u32[polyveck] t0, s2;
    reg ptr u32[polyvecl] s1;
    reg ptr u8[RNDBYTES] rnd;
    reg ptr u8[CRHBYTES] mu;
    reg ptr u8[SEEDBYTES + RNDBYTES + CRHBYTES] key_rnd_mu;
    reg ptr u8[2] mu2;
    reg ptr u32[25*2] pstate;

    stack u32[matKL] matrix_A;
    stack u32[polyvecl] s_y, signer_response;

    stack u32[polyveck] s_h;
    reg ptr u32[polyveck] h;

    reg ptr u32[matKL] matrix_A_ptr;
    stack u32[polyveck] w1 s_w0;
    reg ptr u32[polyveck] w1_pointer w0;

    stack u32[N] challenge;
    reg ptr u32[N] challenge_ptr;

    reg u32 pos m mlen ctx ctxlen t;

    reg u32 continue nonce;

    inline int i;

    status = -1;

    ctxlen = ctxlen_mlen[0];

    if (ctxlen <= 255) {
        () = #spill(ctx_m_rand);

        rho = s_rho;
        key = s_key_rnd_mu[0:SEEDBYTES];
        t0 = s_t0;
        s1 = s_s1;
        s2 = s_s2;

        () = #spill(sig, status, ctxlen, ctxlen_mlen);
        (rho, verification_key_hash, key, t0, s1, s2) = _unpack_sk(rho, verification_key_hash, key, t0, s1, s2, sk);
        s_rho = rho;
        s_t0 = t0;
        s_s1 = s1;
        s_s2 = s2;
        s_key_rnd_mu[0:SEEDBYTES] = key;

        mu2 = s_key_rnd_mu[SEEDBYTES + RNDBYTES : 2];
        t = 0;
        mu2[0] = (8u)t;

        () = #unspill(ctxlen_mlen);
        t = ctxlen_mlen[0];
        () = #spill(ctxlen_mlen);

        mu2[1] = (8u)t;
        s_key_rnd_mu[SEEDBYTES + RNDBYTES : 2] = mu2;

        pstate = state;
        // VERIFICATION_KEY_HASH_SIZE (64) + 2 < SHAKE256_RATE (136)
        pstate = __add_crh(pstate, verification_key_hash); // VERIFICATION_KEY_HASH_SIZE = CRHBYTES

        () = #unspill(ctxlen_mlen);
        t = ctxlen_mlen[0];
        () = #spill(ctxlen_mlen);
        pstate = __add_message_prefix(pstate, t, VERIFICATION_KEY_HASH_SIZE);
        pstate = __add_zero_after_add_naive(pstate, VERIFICATION_KEY_HASH_SIZE + 2);
        pos = VERIFICATION_KEY_HASH_SIZE + 2;

        () = #unspill(ctx_m_rand);
        ctx = ctx_m_rand[0];
        () = #spill(ctx_m_rand);

        () = #unspill(ctxlen);
        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, ctx, ctxlen);

        () = #unspill(ctxlen_mlen);
        mlen = ctxlen_mlen[1];

        () = #unspill(ctx_m_rand);
        m = ctx_m_rand[1];
        () = #spill(ctx_m_rand);

        pstate, pos = _shake256_inc_absorb_mem_naive(pstate, pos, m, mlen);
        pstate = _shake256_add_block_end(pstate, pos);
        pstate = _keccakf1600_ref(pstate);

        mu = s_key_rnd_mu[SEEDBYTES + RNDBYTES : CRHBYTES];
        mu = #copy(pstate.[:u8 0 : CRHBYTES]);
        s_key_rnd_mu[SEEDBYTES + RNDBYTES : CRHBYTES] = mu;

        rnd = s_key_rnd_mu[SEEDBYTES : RNDBYTES];
        () = #unspill(ctx_m_rand);
        reg u32 rand = ctx_m_rand[2];
        for i = 0 to RNDBYTES/4 {
            t = [:u32 rand + 4*i];
            rnd[:u32 i] = t;
        }
        s_key_rnd_mu[SEEDBYTES : RNDBYTES] = rnd;

        key_rnd_mu = s_key_rnd_mu;
        pstate = __add_seedrndcrh_ref(pstate, key_rnd_mu);
        pstate = __add_zero_after_add(pstate, SEEDBYTES + RNDBYTES + CRHBYTES);
        pstate = __add_block_end(pstate, SEEDBYTES + RNDBYTES + CRHBYTES, SHAKE256_RATE);
        pstate = _keccakf1600_ref(pstate);
        state = pstate;

        rhoprime_ptr = rhoprime;
        rhoprime_ptr = #copy(pstate.[:u8 0 : CRHBYTES]);
        rhoprime = rhoprime_ptr;

        #declassify rho = s_rho;
        matrix_A_ptr = matrix_A;
        matrix_A_ptr = _polyvec_matrix_expand(matrix_A_ptr, rho);
        matrix_A = matrix_A_ptr;

        s1 = s_s1; s1 = _polyvecl_ntt(s1); s_s1 = s1;
        s2 = s_s2; s2 = _polyveck_ntt(s2); s_s2 = s2;
        t0 = s_t0; t0 = _polyveck_ntt(t0); s_t0 = t0;

        nonce = 0;
        () = #spill(nonce);
        while {
            /* Sample intermediate vector y */
            () = #unspill(nonce);
            rhoprime_ptr = rhoprime;
            s_y = _polyvecl_uniform_gamma1(s_y, rhoprime_ptr, nonce);

            () = #unspill(nonce);
            nonce += 1;
            () = #spill(nonce);

            /* Matrix-vector multiplication */
            signer_response = __copy_polyvecl(signer_response, s_y);
            signer_response = _polyvecl_ntt(signer_response);
            matrix_A_ptr = matrix_A;
            w1_pointer = w1;
            w1_pointer = _polyvec_matrix_pointwise_montgomery(w1_pointer, matrix_A_ptr, signer_response);
            w1_pointer = _polyveck_reduce(w1_pointer);
            w1_pointer = _polyveck_invntt_tomont(w1_pointer);

            /* Decompose w and call the random oracle */
            w1_pointer = _polyveck_caddq(w1_pointer);
            w0 = s_w0;
            w1_pointer, s_w0 = _polyveck_decompose_inplace(w1_pointer, w0);
            w1 = w1_pointer;
            () = #unspill(sig);
            reg ptr u8[K * POLYW1_PACKEDBYTES] sig1;
            sig1 = sig[0: K * POLYW1_PACKEDBYTES];
            sig1 = _polyveck_pack_w1(sig1, w1_pointer);
            sig[0: K * POLYW1_PACKEDBYTES] = sig1;
            () = #spill(sig);
            // SHAKE256
            pstate = state; mu = s_key_rnd_mu[SEEDBYTES + RNDBYTES : CRHBYTES];
            pstate = __add_crh(pstate, mu);
            pstate = __add_zero_after_add(pstate, CRHBYTES);
            pstate, pos = __derive_commitment_hash(pstate, CRHBYTES, sig1);
            pstate = _shake256_add_block_end(pstate, pos);
            pstate = _keccakf1600_ref(pstate);

            () = #unspill(sig);
            commitment_hash = sig[0:COMMITMENT_HASH_SIZE];
            commitment_hash = #copy(pstate.[:u8 0 : COMMITMENT_HASH_SIZE]);
            sig[0:COMMITMENT_HASH_SIZE] = commitment_hash;

            state = pstate;

            () = #spill(sig);
            challenge_ptr = challenge;

            #declassify commitment_hash = commitment_hash;
            state, challenge_ptr = _poly_challenge(state, challenge_ptr, commitment_hash);
            challenge_ptr = _poly_ntt(challenge_ptr);
            /* Compute z, reject if it reveals secret */
            s1 = s_s1;
            signer_response = _polyvecl_pointwise_poly_montgomery(signer_response, challenge_ptr, s1); challenge = challenge_ptr;
            signer_response = _polyvecl_invntt_tomont(signer_response);
            signer_response = _polyvecl_add_inplace(signer_response, s_y);
            signer_response = _polyvecl_reduce(signer_response);

            reg u32 check_norm bound;
            bound = iGAMMA1 - BETA;
            check_norm = _polyvecl_check_norm(signer_response, bound);
            () = #spill(sig);
            if (check_norm != 0) {
                continue = 1;
            } else {
                s2 = s_s2; h = s_h;
                h = _polyveck_pointwise_poly_montgomery(h, challenge_ptr, s2);
                h = _polyveck_invntt_tomont(h); s_h = h;
                w0 = s_w0;
                w0 = _polyveck_sub_inplace(w0, h);
                w0 = _polyveck_reduce(w0);
                s_w0 = w0;
                bound = iGAMMA2 - BETA;
                check_norm = _polyveck_check_norm(w0, bound);
                if (check_norm != 0) {
                    continue = 1;
                } else {
                    challenge_ptr = challenge;
                    t0 = s_t0;
                    h = h;  // Needed for regalloc
                    h = _polyveck_pointwise_poly_montgomery(h, challenge_ptr, t0);
                    h = _polyveck_invntt_tomont(h);
                    h = h; // Needed for regalloc
                    h = _polyveck_reduce(h);
                    s_h = h;

                    bound = iGAMMA2;
                    check_norm = _polyveck_check_norm(h, bound);
                    if (check_norm != 0) {
                        continue = 1;
                    } else {
                        w0 = s_w0;
                        w0 = _polyveck_add_inplace(w0, h);
                        s_w0 = w0; w1_pointer = w1;
                        reg u32 n;

                        h = s_h;
                        n, h = _polyveck_make_hint(h, w0, w1_pointer);
                        s_h = h;

                        if (n > MAX_ONES_IN_HINT) {
                            continue = 1;
                        } else {
                            () = #unspill(sig);

                            #declassify h = s_h;
                            #declassify signer_response = signer_response;
                            #declassify sig = sig;

                            sig = _pack_sig_nocopy(sig, signer_response, h);
                            () = #spill(sig);
                            continue = 0;
                        }
                    }
                }
            }
        } (continue == 1)
        status = 0;
        () = #unspill(sig);
    }

    #declassify sig = sig;
    return sig, status;
}
