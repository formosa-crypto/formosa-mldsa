fn _polyz_unpack_9_bytes(
    reg ptr u32[4] poly_z_slice,
    reg ptr u8[9] block
) -> reg ptr u32[4]
{
    reg u32 gamma1 temp;
    reg u32[6] t;

    inline int k;

    gamma1 = iGAMMA1;
    () = #spill(gamma1);

    for k = 0 to 6 {
        t[k] = (32u) block[k];
    }

    /*  r->coeffs[4 * i + 0]  = a[9 * i + 0];
        r->coeffs[4 * i + 0] |= (uint32_t)a[9 * i + 1] << 8;
        r->coeffs[4 * i + 0] |= (uint32_t)a[9 * i + 2] << 16;
        r->coeffs[4 * i + 0] &= 0x3FFFF;
    */
    temp = __or_lsl(t[0], t[1], 8);
    temp = __or_lsl_inplace(temp, t[2], 16);
    temp = __ubfx(temp, 0, 18);

    () = #unspill(gamma1);
    temp = gamma1 - temp;

    poly_z_slice[0] = temp;

    /*  r->coeffs[4 * i + 1]  = a[9 * i + 2] >> 2;
        r->coeffs[4 * i + 1] |= (uint32_t)a[9 * i + 3] << 6;
        r->coeffs[4 * i + 1] |= (uint32_t)a[9 * i + 4] << 14;
        r->coeffs[4 * i + 1] &= 0x3FFFF;
    */
    temp = t[2] >> 2;
    temp = __or_lsl_inplace(temp, t[3], 6);
    temp = __or_lsl_inplace(temp, t[4], 14);
    temp = __ubfx(temp, 0, 18);

    () = #unspill(gamma1);
    temp = gamma1 - temp;

    poly_z_slice[1] = temp;

    /*  r->coeffs[4 * i + 2]  = a[9 * i + 4] >> 4;
        r->coeffs[4 * i + 2] |= (uint32_t)a[9 * i + 5] << 4;
        r->coeffs[4 * i + 2] |= (uint32_t)a[9 * i + 6] << 12;
        r->coeffs[4 * i + 2] &= 0x3FFFF;
    */
    temp = t[4] >> 4;
    temp = __or_lsl_inplace(temp, t[5], 4);

    // Reuse t[0], t[1], t[2] to store t[6], t[7], t[8]

    t[0] = (32u)block[6];
    t[1] = (32u)block[7];
    t[2] = (32u)block[8];

    temp = __or_lsl_inplace(temp, t[0], 12);
    temp = __ubfx(temp, 0, 18);

    () = #unspill(gamma1);
    temp = gamma1 - temp;

    poly_z_slice[2] = temp;

    /*  r->coeffs[4 * i + 3]  = a[9 * i + 6] >> 6;
        r->coeffs[4 * i + 3] |= (uint32_t)a[9 * i + 7] << 2;
        r->coeffs[4 * i + 3] |= (uint32_t)a[9 * i + 8] << 10;
        r->coeffs[4 * i + 3] &= 0x3FFFF;
    */
    temp = t[0] >> 6;
    temp = __or_lsl_inplace(temp, t[1], 2);

    temp = __or_lsl_inplace(temp, t[2], 10);
    temp = __ubfx(temp, 0, 18);

    () = #unspill(gamma1);
    temp = gamma1 - temp;

    poly_z_slice[3] = temp;

    return poly_z_slice;
}

fn _polyz_unpack_streaming(
    reg ptr u32[N] poly_z,
    reg u32 fill_from,
    reg u32 num_leftover_bytes,
    reg ptr u8[9] first_9_bytes,
    reg ptr u8[SHAKE256_RATE] bytes
) -> reg ptr u32[N],
     reg u32,
     reg u32,
     reg ptr u8[9]
{
    reg u32 bytes_index;
    reg u32 j;
    reg u32 to_copy;

    j = num_leftover_bytes;
    bytes_index = 0;
    while (j < 9) {
        to_copy = (32u)bytes[bytes_index];
        bytes_index += 1;

        first_9_bytes[j] = (8u)to_copy;
        j += 1;
    }

    poly_z[fill_from : 4] = _polyz_unpack_9_bytes(poly_z[fill_from : 4], first_9_bytes);
    fill_from += 4;
    first_9_bytes = first_9_bytes;

    while(bytes_index < SHAKE256_RATE - 9) {
        poly_z[fill_from : 4] = _polyz_unpack_9_bytes(poly_z[fill_from : 4], bytes[bytes_index : 9]);
        fill_from += 4;

        bytes_index += 9;
    }

    num_leftover_bytes = 0;
    while (bytes_index < SHAKE256_RATE) {
        to_copy = (32u)bytes[bytes_index];
        bytes_index += 1;

        first_9_bytes[num_leftover_bytes] = (8u)to_copy;
        num_leftover_bytes += 1;
    }

    return poly_z, fill_from, num_leftover_bytes, first_9_bytes;
}
fn _polyz_unpack_streaming_end(
    reg ptr u32[N] poly_z,
    reg ptr u8[9] first_9_bytes,
    reg ptr u8[32] bytes
) -> reg ptr u32[N],
     reg ptr u8[9]
{
    reg u32 bytes_index;
    reg u32 to_copy;
    reg u32 fill_from;

    to_copy = bytes.[:u32 0];
    first_9_bytes.[:u32 4] = to_copy;

    to_copy = (32u)bytes[4];
    first_9_bytes.[8] = (8u)to_copy;

    fill_from = 240;
    poly_z[fill_from : 4] = _polyz_unpack_9_bytes(poly_z[fill_from : 4], first_9_bytes);
    fill_from += 4;

    bytes_index = 5;
    while(bytes_index < 32) {
        poly_z[fill_from : 4] = _polyz_unpack_9_bytes(poly_z[fill_from : 4], bytes[bytes_index : 9]);
        fill_from += 4;

        bytes_index += 9;
    }

    return poly_z, first_9_bytes;
}
