fn _polyz_pack(reg ptr u8[POLYZ_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYZ_PACKEDBYTES] {
    reg u32 i, j, aux, gamma1;
    reg u32[2] t;
    inline int k;

    gamma1 = iGAMMA1;

    i = 0; j = 0;
    while (i < N) {
        for k = 0 to 2 {
            t[k] = a[i]; t[k] = gamma1 - t[k];
            i += 1;
        }

        /* r[5 * i + 0]  = (uint8_t) t[0]; */
        r[j] = t[0]; j += 1;

        /* r[5 * i + 1]  = (uint8_t) (t[0] >> 8); */
        aux = t[0] >> 8;
        r[j] = aux; j += 1;

        /* r[5 * i + 2]  = (uint8_t) (t[0] >> 16); */
        /* r[5 * i + 2] |= (uint8_t) (t[1] << 4); */

        aux = t[0] >> 16;
        aux = __or_lsl_inplace(aux, t[1], 4);
        r[j] = aux; j += 1;

        /* r[5 * i + 3]  = (uint8_t) (t[1] >> 4); */
        aux = t[1] >> 4;
        r[j] = aux; j += 1;

        /* r[5 * i + 4]  = (uint8_t) (t[1] >> 12); */
        aux = t[1] >> 12;
        r[j] = aux; j += 1;

    }
    return r;
}

fn _polyz_unpack_5_bytes(
    reg ptr u32[2] poly_z_slice,
    reg ptr u8[5] block
) -> reg ptr u32[2]
{
    reg u32[5] t;
    reg u32 aux;

    inline int k;

    reg u32 gamma1 = iGAMMA1;

    for k = 0 to 5 { t[k] = (32u) block[k]; }

    aux = __or_lsl(t[0], t[1], 8);
    aux = __or_lsl_inplace(aux, t[2], 16);
    aux = __ubfx(aux, 0, 20);
    aux = gamma1 - aux;
    poly_z_slice[0] = aux;

    aux = t[2] >> 4;
    aux = __or_lsl_inplace(aux, t[3], 4);
    aux = __or_lsl_inplace(aux, t[4], 12);
    aux = gamma1 - aux;
    poly_z_slice[1] = aux;

    return poly_z_slice;
}
fn _polyz_unpack(
    reg ptr u32[N] poly_z,
    reg ptr u8[POLYZ_PACKEDBYTES] bytes
) -> reg ptr u32[N]
{
    reg u32 i = 0;
    reg u32 j = 0;

    while(i < POLYZ_PACKEDBYTES) {
        poly_z[j : 2] = _polyz_unpack_5_bytes(poly_z[j : 2], bytes[i : 5]);
        j += 2;
        i += 5;
    }

    return poly_z;
}


fn _polyz_unpack_streaming(
    reg ptr u32[N] poly_z,
    reg u32 fill_from,
    reg u32 num_leftover_bytes,
    reg ptr u8[5] first_5_bytes,
    reg ptr u8[SHAKE256_RATE] bytes
) -> reg ptr u32[N],
     reg u32,
     reg u32,
     reg ptr u8[5]
{
    reg u32 bytes_index;
    reg u32 j;
    reg u32 to_copy;

    j = num_leftover_bytes;
    bytes_index = 0;
    while (j < 5) {
        to_copy = (32u)bytes[bytes_index];
        bytes_index += 1;

        first_5_bytes[j] = (8u)to_copy;
        j += 1;
    }

    poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], first_5_bytes);
    fill_from += 2;
    first_5_bytes = first_5_bytes;

    while(bytes_index < SHAKE256_RATE - 5) {
        poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], bytes[bytes_index : 5]);
        fill_from += 2;

        bytes_index += 5;
    }

    num_leftover_bytes = 0;
    while (bytes_index < SHAKE256_RATE) {
        to_copy = (32u)bytes[bytes_index];
        bytes_index += 1;

        first_5_bytes[num_leftover_bytes] = (8u)to_copy;
        num_leftover_bytes += 1;
    }

    return poly_z, fill_from, num_leftover_bytes, first_5_bytes;
}
fn _polyz_unpack_streaming_end(
    reg ptr u32[N] poly_z,
    reg ptr u8[5] first_5_bytes,
    reg ptr u8[96] bytes
) -> reg ptr u32[N],
     reg ptr u8[5]
{
    reg u32 bytes_index;
    reg u32 to_copy;
    reg u32 fill_from;

    to_copy = (32u)bytes[0];
    first_5_bytes[4] = (8u)to_copy;

    fill_from = 216;
    poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], first_5_bytes);
    fill_from += 2;

    bytes_index = 1;
    while(bytes_index < 96) {
        poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], bytes[bytes_index : 5]);
        fill_from += 2;

        bytes_index += 5;
    }

    return poly_z, first_5_bytes;
}
