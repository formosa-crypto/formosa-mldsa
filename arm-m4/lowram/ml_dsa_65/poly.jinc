fn _poly_uniform_gamma1(
    reg ptr u32[N] poly,
    reg ptr u8[CRHBYTES] seed,
    reg u32 nonce
) -> reg ptr u32[N]
{
    stack u32[25 * 2] state;

    reg u32 num_leftover_bytes fill_from;
    stack u8[5] first_5_bytes;

    inline int k;

    state = _prepare_state_for_shake256(state, seed, nonce);
    () = #spill(poly);
    state = _keccakf1600_ref(state);
    () = #unspill(poly);

    num_leftover_bytes = 0;
    fill_from = 0;
    for k = 0 to 4 {
        first_5_bytes = first_5_bytes;
        poly, fill_from, num_leftover_bytes, first_5_bytes = _polyz_unpack_streaming(poly, fill_from, num_leftover_bytes, first_5_bytes, state[:u8 0 : SHAKE256_RATE]);

        () = #spill(poly, num_leftover_bytes, fill_from);
        state = _keccakf1600_ref(state);
        () = #unspill(poly, num_leftover_bytes, fill_from);
    }

    first_5_bytes = first_5_bytes;
    poly, first_5_bytes = _polyz_unpack_streaming_end(poly, first_5_bytes, state[:u8 0 : 96]);

    return poly;
}

inline fn __extr_rej_sample(
        reg ptr u32[N] a,
        reg u32 ctr,
        reg u32 t,
        reg u32 q
        ) -> reg ptr u32[N], reg u32
{
    t = __ubfx(t, 0, 23);
    a, ctr = __rej_sample(a, ctr, t, q);
    return a, ctr;
}

fn _poly_uniform(
    reg ptr u32[N] sampled,
    reg ptr u32[25 * 2] state
) -> reg ptr u32[N],
     reg ptr u32[25 * 2]
{
    reg u32 ctr, ctr4, pos, q, t;
    reg u32[3] buf;

    ctr = 0; pos = 0; q = iQ;

    while { ctr4 = ctr + 4; } (ctr4 < N) {
        state, sampled, pos, ctr, q, buf = _stream128_refill_buffer(state, sampled, pos, ctr, q);

        sampled, ctr = __extr_rej_sample(sampled, ctr, buf[0], q);  // 3 bytes in buf[0]

        t = buf[0] >>u 24;
        t = __or_lsl_inplace(t, buf[1], 8);
        sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);

        t = buf[1] >>u 16;
        t = __or_lsl_inplace(t, buf[2], 16);  // 2 byte in buf[1] U 1 bytes in buf[2]
        sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);

        t = __ubfx(buf[2], 8, 23);
        sampled, ctr = __rej_sample(sampled, ctr, t, q);
    }

    while (ctr < N) {
        state, sampled, pos, ctr, q, buf = _stream128_refill_buffer(state, sampled, pos, ctr, q);

        sampled, ctr = __extr_rej_sample(sampled, ctr, buf[0], q);  // 3 bytes in buf[0]

        if (ctr < N) {
            t = buf[0] >>u 24;
            t = __or_lsl_inplace(t, buf[1], 8); // 1 byte in buf[0] U 2 bytes in buf[1]
            sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);
        }

        if (ctr < N) {
            t = buf[1] >>u 16;
            t = __or_lsl_inplace(t, buf[2], 16); // 2 byte in buf[1] U 1 bytes in buf[2]
            sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);
        }

        if (ctr < N) {
            t = __ubfx(buf[2], 8, 23);
            sampled, ctr = __rej_sample(sampled, ctr, t, q);
        }
    }

    return sampled, state;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_uniform_eta
 *
 * Description: Sample polynomial with uniformly random coefficients
 *              in [-ETA,ETA] by performing rejection sampling on the
 *              output stream from SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
 *
 * Arguments:   - poly *a: pointer to output polynomial
 *              - const uint8_t seed[]: byte array with seed of length CRHBYTES
 *              - uint16_t nonce: 2-byte nonce
 **************************************************/

inline fn rej_eta(
        reg ptr u32[N] a,
        reg u32 ctr,
        reg u32 t
        ) -> reg ptr u32[N], reg u32
{
    #declassify t = t;
    if (t < 9) {
        a[ctr] = __imm_sub_reg(4, t);
        ctr += 1;
    }
    return a, ctr;
}

fn _poly_uniform_eta(
    reg ptr u32[N] poly,
    #secret reg ptr u8[CRHBYTES] seed,
    reg u32 nonce
) -> reg ptr u32[N]
{
    stack u32[25*2] state;
    reg u32 ctr, ctr8, pos, n205, t;
    reg u32 buf;

    () = #spill(poly);
    state = _prepare_state_for_shake256(state, seed, nonce);
    state = _keccakf1600_ref(state);
    () = #unspill(poly);

    ctr = 0;
    pos = 0;
    n205 = 205;
    while {
        ctr8 = ctr + 8;
    } (ctr8 < N) {

        state, poly, pos, ctr, n205, buf = _stream256_refill_buffer(state, poly, pos, ctr, n205);
        inline int i;
        for i = 0 to 8 {
            t = __ubfx(buf, 4*i, 4);
            poly, ctr = rej_eta(poly, ctr, t);
        }
    }

    while (ctr < N) {
        state, poly, pos, ctr, n205, buf = _stream256_refill_buffer(state, poly, pos, ctr, n205);
        inline int i;
        for i = 0 to 8 {
            if ((i == 0) || (ctr < N)) {
                t = __ubfx(buf, 4*i, 4);
                poly, ctr = rej_eta(poly, ctr, t);
            }
        }
    }
    return poly;
}


fn _poly_compress_challenge(
    reg ptr u8[COMPRESSED_CHALLENGE_SIZE] compressed_challenge,
    reg ptr u32[N] challenge
) -> reg ptr u8[COMPRESSED_CHALLENGE_SIZE]
{
    reg u32 zero = 0;
    reg u32 output_offset = 0;
    reg u32 ones_seen = 0;

    reg u32 mask = 1;
    reg u32 signs = 0;

    reg u32 coeff;

    reg u32 i = 0;

    while (ones_seen < 32) {
        coeff = challenge[i];

        if (coeff != 0) {
            compressed_challenge[output_offset] = i;
            output_offset += 1;

            if (coeff == -1) {
                signs |= mask;
            }

            mask <<= 1;
            ones_seen += 1;
        }

        i += 1;
    }
    compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 8] = signs;

    mask = 1;
    signs = 0;
    while (i < N) {
        coeff = challenge[i];

        if (coeff != 0) {
            compressed_challenge[output_offset] = i;
            output_offset += 1;

            if (coeff == -1) {
                signs |= mask;
            }

            mask <<= 1;
        }

        i += 1;
    }
    compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 4] = signs;

    return compressed_challenge;
}

fn _poly_decompress_challenge(
    reg ptr u32[N] challenge,
    reg ptr u8[COMPRESSED_CHALLENGE_SIZE] compressed_challenge
) -> reg ptr u32[N]
{
    reg u32 signs;
    reg u32 sign next_nonzero_index;

    reg u32 zero = 0;
    reg u32 i = 0;

    while (i < N) {
        challenge[i] = zero;
        i += 1;
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 8];
    i = 0;
    while (i < 32) {
        next_nonzero_index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        if (sign == 1) {
            sign = -1;
        } else {
            sign = 1;
        }

        challenge[next_nonzero_index] = sign;
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 4];
    while (i < TAU) {
        next_nonzero_index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        if (sign == 1) {
            sign = -1;
        } else {
            sign = 1;
        }

        challenge[next_nonzero_index] = sign;
    }

    return challenge;
}
