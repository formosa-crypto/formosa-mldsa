/*************************************************
 * Name:        JASMIN_MLDSA_polyeta_pack
 *
 * Description: Bit-pack polynomial with coefficients in [-ETA,ETA].
 *
 * Arguments:   - uint8_t *r: pointer to output byte array with at least
 *                            POLYETA_PACKEDBYTES bytes
 *              - const poly *a: pointer to input polynomial
 **************************************************/

fn _polyeta_pack(
    reg ptr u8[POLYETA_PACKEDBYTES] r,
    reg ptr u32[N] a
) -> reg ptr u8[POLYETA_PACKEDBYTES] {

    reg u32 i, j;
    reg u32[8] t;
    /*
       for (i = 0; i < N / 2; ++i) {
       t[0] = (uint8_t) (ETA - a->coeffs[2 * i + 0]);
       t[1] = (uint8_t) (ETA - a->coeffs[2 * i + 1]);
       r[i] = t[0] | (t[1] << 4);
       }
     */

    i = 0; j = 0;
    while(i < N) {
        inline int k;
        for k = 0 to 2 {
            t[k] = __eta_minus_coeff(a, i);
            i += 1;
        }
        reg u32 aux;
        aux = __or_lsl(t[0], t[1], 4);
        r[j] = aux;
        j += 1;
    }
    return r;

}

/*************************************************
 * Name:        JASMIN_MLDSA_polyeta_unpack
 *
 * Description: Unpack polynomial with coefficients in [-ETA,ETA].
 *
 * Arguments:   - poly *r: pointer to output polynomial
 *              - const uint8_t *a: byte array with bit-packed polynomial
 **************************************************/

inline fn _polyeta_unpack(
        reg ptr u32[N] r,
        reg ptr u8[POLYETA_PACKEDBYTES] a
        ) -> reg ptr u32[N] {
    reg u32 i, j;
    reg u32 t0 t1;
    reg u32 aux;
    i = 0; j = 0;

    while(i < N) {
        aux = (32u) a[j];
        t0 =  aux & 0x0F;
        r[i] =  __imm_sub_reg(ETA, t0);
        i += 1;
        t1 =  aux >> 4;
        r[i] =  __imm_sub_reg(ETA, t1);
        i += 1;
        j +=1 ;
    }
    return r;
}

/*************************************************
 * Name:        JASMIN_MLDSA_polyw1_pack
 *
 * Description: Bit-pack polynomial w1 with coefficients in [0,15] or [0,43].
 *              Input coefficients are assumed to be standard representatives.
 *
 * Arguments:   - uint8_t *r: pointer to output byte array with at least
 *                            POLYW1_PACKEDBYTES bytes
 *              - const poly *a: pointer to input polynomial
 **************************************************/

fn _polyw1_pack(reg ptr u8[POLYW1_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYW1_PACKEDBYTES] {
    reg u32 i, j, aux;
    reg u32[2] t;
    inline int k;
    i = 0; j = 0;
    while (i < N) {
        for k = 0 to 2 { t[k] = a[i]; i += 1; }
        aux = __or_lsl(t[0], t[1], 4);
        r[j] = aux; j += 1;
    }
    return r;
}

/*************************************************
 * Name:        JASMIN_MLDSA_polyz_pack
 *
 * Description: Bit-pack polynomial with coefficients
 *              in [-(GAMMA1 - 1), GAMMA1].
 *
 * Arguments:   - uint8_t *r: pointer to output byte array with at least
 *                            POLYZ_PACKEDBYTES bytes
 *              - const poly *a: pointer to input polynomial
 **************************************************/
fn _polyz_pack(reg ptr u8[POLYZ_PACKEDBYTES] r, reg ptr u32[N] a) -> reg ptr u8[POLYZ_PACKEDBYTES] {
    reg u32 i, j, aux, gamma1;
    reg u32[2] t;
    inline int k;

    gamma1 = iGAMMA1;

    i = 0; j = 0;
    while (i < N) {
        for k = 0 to 2 {
            t[k] = a[i]; t[k] = gamma1 - t[k];
            i += 1;
        }

        /* r[5 * i + 0]  = (uint8_t) t[0]; */
        r[j] = t[0]; j += 1;

        /* r[5 * i + 1]  = (uint8_t) (t[0] >> 8); */
        aux = t[0] >> 8;
        r[j] = aux; j += 1;

        /* r[5 * i + 2]  = (uint8_t) (t[0] >> 16); */
        /* r[5 * i + 2] |= (uint8_t) (t[1] << 4); */

        aux = t[0] >> 16;
        aux = __or_lsl_inplace(aux, t[1], 4);
        r[j] = aux; j += 1;

        /* r[5 * i + 3]  = (uint8_t) (t[1] >> 4); */
        aux = t[1] >> 4;
        r[j] = aux; j += 1;

        /* r[5 * i + 4]  = (uint8_t) (t[1] >> 12); */
        aux = t[1] >> 12;
        r[j] = aux; j += 1;

    }
    return r;
}

/*************************************************
 * Name:        JASMIN_MLDSA_polyz_unpack
 *
 * Description: Unpack polynomial z with coefficients
 *              in [-(GAMMA1 - 1), GAMMA1].
 *
 * Arguments:   - poly *r: pointer to output polynomial
 *              - const uint8_t *a: byte array with bit-packed polynomial
 **************************************************/
fn _polyz_unpack_5_bytes(
    reg ptr u32[2] poly_z_slice,
    reg ptr u8[5] block
) -> reg ptr u32[2]
{
    reg u32[5] t;
    reg u32 aux;

    inline int k;

    reg u32 gamma1 = iGAMMA1;

    for k = 0 to 5 { t[k] = (32u) block[k]; }

    aux = __or_lsl(t[0], t[1], 8);
    aux = __or_lsl_inplace(aux, t[2], 16);
    aux = __ubfx(aux, 0, 20);
    aux = gamma1 - aux;
    poly_z_slice[0] = aux;

    aux = t[2] >> 4;
    aux = __or_lsl_inplace(aux, t[3], 4);
    aux = __or_lsl_inplace(aux, t[4], 12);
    aux = gamma1 - aux;
    poly_z_slice[1] = aux;

    return poly_z_slice;
}
fn _polyz_unpack(
    reg ptr u32[N] poly_z,
    reg ptr u8[POLYZ_PACKEDBYTES] bytes
) -> reg ptr u32[N]
{
    reg u32 i = 0;
    reg u32 j = 0;

    while(i < POLYZ_PACKEDBYTES) {
        poly_z[j : 2] = _polyz_unpack_5_bytes(poly_z[j : 2], bytes[i : 5]);
        j += 2;
        i += 5;
    }

    return poly_z;
}


fn _polyz_unpack_streaming(
    reg ptr u32[N] poly_z,
    reg u32 fill_from,
    reg u32 num_leftover_bytes,
    reg ptr u8[5] first_5_bytes,
    reg ptr u8[SHAKE256_RATE] bytes
) -> reg ptr u32[N],
     reg u32,
     reg u32,
     reg ptr u8[5]
{
    reg u32 bytes_index;
    reg u32 j;
    reg u32 to_copy;

    j = num_leftover_bytes;
    bytes_index = 0;
    while (j < 5) {
        to_copy = (32u)bytes[bytes_index];
        bytes_index += 1;

        first_5_bytes[j] = (8u)to_copy;
        j += 1;
    }

    poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], first_5_bytes);
    fill_from += 2;
    first_5_bytes = first_5_bytes;

    while(bytes_index < SHAKE256_RATE - 5) {
        poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], bytes[bytes_index : 5]);
        fill_from += 2;

        bytes_index += 5;
    }

    num_leftover_bytes = 0;
    while (bytes_index < SHAKE256_RATE) {
        to_copy = (32u)bytes[bytes_index];
        bytes_index += 1;

        first_5_bytes[num_leftover_bytes] = (8u)to_copy;
        num_leftover_bytes += 1;
    }

    return poly_z, fill_from, num_leftover_bytes, first_5_bytes;
}
fn _polyz_unpack_streaming_end(
    reg ptr u32[N] poly_z,
    reg ptr u8[5] first_5_bytes,
    reg ptr u8[96] bytes
) -> reg ptr u32[N],
     reg ptr u8[5]
{
    reg u32 bytes_index;
    reg u32 to_copy;
    reg u32 fill_from;

    to_copy = (32u)bytes[0];
    first_5_bytes[4] = (8u)to_copy;

    fill_from = 216;
    poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], first_5_bytes);
    fill_from += 2;

    bytes_index = 1;
    while(bytes_index < 96) {
        poly_z[fill_from : 2] = _polyz_unpack_5_bytes(poly_z[fill_from : 2], bytes[bytes_index : 5]);
        fill_from += 2;

        bytes_index += 5;
    }

    return poly_z, first_5_bytes;
}
fn _poly_uniform_gamma1(
    reg ptr u32[N] poly,
    reg ptr u8[CRHBYTES] seed,
    reg u32 nonce
) -> reg ptr u32[N]
{
    stack u32[25 * 2] state;

    reg u32 num_leftover_bytes fill_from;
    stack u8[5] first_5_bytes;

    inline int k;

    state = _prepare_state_for_shake256(state, seed, nonce);
    () = #spill(poly);
    state = _keccakf1600_ref(state);
    () = #unspill(poly);

    num_leftover_bytes = 0;
    fill_from = 0;
    for k = 0 to 4 {
        first_5_bytes = first_5_bytes;
        poly, fill_from, num_leftover_bytes, first_5_bytes = _polyz_unpack_streaming(poly, fill_from, num_leftover_bytes, first_5_bytes, state[:u8 0 : SHAKE256_RATE]);

        () = #spill(poly, num_leftover_bytes, fill_from);
        state = _keccakf1600_ref(state);
        () = #unspill(poly, num_leftover_bytes, fill_from);
    }

    first_5_bytes = first_5_bytes;
    poly, first_5_bytes = _polyz_unpack_streaming_end(poly, first_5_bytes, state[:u8 0 : 96]);

    return poly;
}

inline fn __extr_rej_sample(
        reg ptr u32[N] a,
        reg u32 ctr,
        reg u32 t,
        reg u32 q
        ) -> reg ptr u32[N], reg u32
{
    t = __ubfx(t, 0, 23);
    a, ctr = __rej_sample(a, ctr, t, q);
    return a, ctr;
}

fn _poly_uniform(
    reg ptr u32[N] sampled,
    reg ptr u32[25 * 2] state
) -> reg ptr u32[N],
     reg ptr u32[25 * 2]
{
    reg u32 ctr, ctr4, pos, q, t;
    reg u32[3] buf;

    ctr = 0; pos = 0; q = iQ;

    while { ctr4 = ctr + 4; } (ctr4 < N) {
        state, sampled, pos, ctr, q, buf = _stream128_refill_buffer(state, sampled, pos, ctr, q);

        sampled, ctr = __extr_rej_sample(sampled, ctr, buf[0], q);  // 3 bytes in buf[0]

        t = buf[0] >>u 24;
        t = __or_lsl_inplace(t, buf[1], 8);
        sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);

        t = buf[1] >>u 16;
        t = __or_lsl_inplace(t, buf[2], 16);  // 2 byte in buf[1] U 1 bytes in buf[2]
        sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);

        t = __ubfx(buf[2], 8, 23);
        sampled, ctr = __rej_sample(sampled, ctr, t, q);
    }

    while (ctr < N) {
        state, sampled, pos, ctr, q, buf = _stream128_refill_buffer(state, sampled, pos, ctr, q);

        sampled, ctr = __extr_rej_sample(sampled, ctr, buf[0], q);  // 3 bytes in buf[0]

        if (ctr < N) {
            t = buf[0] >>u 24;
            t = __or_lsl_inplace(t, buf[1], 8); // 1 byte in buf[0] U 2 bytes in buf[1]
            sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);
        }

        if (ctr < N) {
            t = buf[1] >>u 16;
            t = __or_lsl_inplace(t, buf[2], 16); // 2 byte in buf[1] U 1 bytes in buf[2]
            sampled, ctr = __extr_rej_sample(sampled, ctr, t, q);
        }

        if (ctr < N) {
            t = __ubfx(buf[2], 8, 23);
            sampled, ctr = __rej_sample(sampled, ctr, t, q);
        }
    }

    return sampled, state;
}

/*************************************************
 * Name:        JASMIN_MLDSA_poly_uniform_eta
 *
 * Description: Sample polynomial with uniformly random coefficients
 *              in [-ETA,ETA] by performing rejection sampling on the
 *              output stream from SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
 *
 * Arguments:   - poly *a: pointer to output polynomial
 *              - const uint8_t seed[]: byte array with seed of length CRHBYTES
 *              - uint16_t nonce: 2-byte nonce
 **************************************************/

inline fn rej_eta(
        reg ptr u32[N] a,
        reg u32 ctr,
        reg u32 t
        ) -> reg ptr u32[N], reg u32
{
    #declassify t = t;
    if (t < 9) {
        a[ctr] = __imm_sub_reg(4, t);
        ctr += 1;
    }
    return a, ctr;
}

fn _poly_uniform_eta(
    reg ptr u32[N] poly,
    #secret reg ptr u8[CRHBYTES] seed,
    reg u32 nonce
) -> reg ptr u32[N]
{
    stack u32[25*2] state;
    reg u32 ctr, ctr8, pos, n205, t;
    reg u32 buf;

    () = #spill(poly);
    state = _prepare_state_for_shake256(state, seed, nonce);
    state = _keccakf1600_ref(state);
    () = #unspill(poly);

    ctr = 0;
    pos = 0;
    n205 = 205;
    while {
        ctr8 = ctr + 8;
    } (ctr8 < N) {

        state, poly, pos, ctr, n205, buf = _stream256_refill_buffer(state, poly, pos, ctr, n205);
        inline int i;
        for i = 0 to 8 {
            t = __ubfx(buf, 4*i, 4);
            poly, ctr = rej_eta(poly, ctr, t);
        }
    }

    while (ctr < N) {
        state, poly, pos, ctr, n205, buf = _stream256_refill_buffer(state, poly, pos, ctr, n205);
        inline int i;
        for i = 0 to 8 {
            if ((i == 0) || (ctr < N)) {
                t = __ubfx(buf, 4*i, 4);
                poly, ctr = rej_eta(poly, ctr, t);
            }
        }
    }
    return poly;
}


fn _poly_compress_challenge(
    reg ptr u8[COMPRESSED_CHALLENGE_SIZE] compressed_challenge,
    reg ptr u32[N] challenge
) -> reg ptr u8[COMPRESSED_CHALLENGE_SIZE]
{
    reg u32 zero = 0;
    reg u32 output_offset = 0;
    reg u32 ones_seen = 0;

    reg u32 mask = 1;
    reg u32 signs = 0;

    reg u32 coeff;

    reg u32 i = 0;

    while (ones_seen < 32) {
        coeff = challenge[i];

        if (coeff != 0) {
            compressed_challenge[output_offset] = i;
            output_offset += 1;

            if (coeff == -1) {
                signs |= mask;
            }

            mask <<= 1;
            ones_seen += 1;
        }

        i += 1;
    }
    compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 8] = signs;

    mask = 1;
    signs = 0;
    while (i < N) {
        coeff = challenge[i];

        if (coeff != 0) {
            compressed_challenge[output_offset] = i;
            output_offset += 1;

            if (coeff == -1) {
                signs |= mask;
            }

            mask <<= 1;
        }

        i += 1;
    }
    compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 4] = signs;

    return compressed_challenge;
}

fn _poly_decompress_challenge(
    reg ptr u32[N] challenge,
    reg ptr u8[COMPRESSED_CHALLENGE_SIZE] compressed_challenge
) -> reg ptr u32[N]
{
    reg u32 signs;
    reg u32 sign next_nonzero_index;

    reg u32 zero = 0;
    reg u32 i = 0;

    while (i < N) {
        challenge[i] = zero;
        i += 1;
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 8];
    i = 0;
    while (i < 32) {
        next_nonzero_index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        if (sign == 1) {
            sign = -1;
        } else {
            sign = 1;
        }

        challenge[next_nonzero_index] = sign;
    }

    signs = compressed_challenge.[:u32 COMPRESSED_CHALLENGE_SIZE - 4];
    while (i < TAU) {
        next_nonzero_index = (32u)compressed_challenge[i];
        i += 1;

        sign = signs & 1;
        signs >>= 1;

        if (sign == 1) {
            sign = -1;
        } else {
            sign = 1;
        }

        challenge[next_nonzero_index] = sign;
    }

    return challenge;
}
