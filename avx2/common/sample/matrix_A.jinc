require "../hashing_4x.jinc"

fn shake128_absorb4x_34(
    reg ptr u8[32] rho,
    reg ptr u16[4] domain_separators,
    reg ptr u256[25] state
) -> reg ptr u256[25]
{
    inline int i;

    reg u256 t0 t1;
    reg u16 t16;
    reg u64 t64;

    for i = 0 to 25 {
        t0 = #set0_256();
        state[i] = t0;
    }

    for i = 0 to 4
    {
        t64 = rho[u64 i];
        state[u64 4 * i] ^= t64;

        t64 = rho[u64 i];
        state[u64 4 * i + 1] ^= t64;

        t64 = rho[u64 i];
        state[u64 4 * i + 2] ^= t64;

        t64 = rho[u64 i];
        state[u64 4 * i + 3] ^= t64;
    }

    t16 = domain_separators[0];
    state[u16 64] ^= t16;
    state[u8 130] ^= 0x1F;

    t16 = domain_separators[1];
    state[u16 68] ^= t16;
    state[u8 138] ^= 0x1F;

    t16 = domain_separators[2];
    state[u16 72] ^= t16;
    state[u8 146] ^= 0x1F;

    t16 = domain_separators[3];
    state[u16 76] ^= t16;
    state[u8 154] ^= 0x1F;

    t0 = shake_sep[u256 0];
    t1 = state[SHAKE128_RATE / 8 - 1];
    t0 = t0 ^ t1;
    state[SHAKE128_RATE / 8 - 1] = t0;

    return state;
}

fn rejection_sample_init(
    reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] polynomial,
    reg ptr u8[SHAKE128_RATE] block
) -> reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL],
     reg u64
{
    // Assume the XOF buffer is full.
    //
    // Extract until:
    //   * The polynomial buffer is full, or
    //   * The XOF buffer is empty.
    //
    // Note: This function relies on the fact that the amount of bytes
    // needed to sample a coefficient mod q (3 bytes) aligns with the
    // SHAKE128 rate (168 bytes).  That is why we don't have to stash
    // any bytes in some scratch space between calls.
    //

    reg u32[3] bytes;
    reg u8 stop_sampling;
    reg u32 coeff;
    reg u64 block_offset = 0;
    reg u64 filled = 0;

    inline int i;

    stop_sampling = 0;
    while (stop_sampling == 0) {
        for i = 0 to 3 {
            bytes[i] = (32u)block[block_offset];
            block_offset += 1;
        }

        coeff = bytes[0];
        bytes[1] <<= 8;
        coeff |= bytes[1];
        bytes[2] <<= 16;
        coeff |= bytes[2];

        // Rejection-sample
        coeff &= 0x7F_FF_FF;
        if coeff < MODULUS {
            polynomial[filled] = coeff;
            filled += 1;
            if filled >= COEFFICIENTS_IN_POLYNOMIAL {
                stop_sampling = 1;
            }
        }

        if block_offset >= SHAKE128_RATE {
            // We've run out of random bytes.
            stop_sampling = 1;
        }
    }

    return polynomial, filled;
}

fn rejection_sample(
    reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL] polynomial,
    reg u64 filled,
    reg ptr u8[SHAKE128_RATE] block
) -> reg ptr u32[COEFFICIENTS_IN_POLYNOMIAL],
     reg u64
{
    // Assume the XOF buffer is full.
    //
    // Extract until:
    //   * The polynomial buffer is full, or
    //   * The XOF buffer is empty.
    //
    // Note: This function relies on the fact that the amount of bytes
    // needed to sample a coefficient mod q (3 bytes) aligns with the
    // SHAKE128 rate (168 bytes).  That is why we don't have to stash
    // any bytes in some scratch space between calls.
    //

    reg u32 byte0 byte1 byte2;
    reg u8 stop_sampling;
    reg u32 coeff;
    reg u64 block_offset = 0;

    stop_sampling = 0;
    while (stop_sampling == 0) {
        byte0 = (32u)block[block_offset];
        block_offset += 1;

        byte1 = (32u)block[block_offset];
        block_offset += 1;

        byte2 = (32u)block[block_offset];
        block_offset += 1;

        coeff = byte0;
        byte1 <<= 8;
        coeff |= byte1;
        byte2 <<= 16;
        coeff |= byte2;

        // Rejection-sample
        coeff &= 0x7F_FF_FF;
        if coeff < MODULUS {
            polynomial[filled] = coeff;
            filled += 1;
            if filled >= COEFFICIENTS_IN_POLYNOMIAL {
                stop_sampling = 1;
            }
        }

        if block_offset >= SHAKE128_RATE {
            // We've run out of random bytes.
            stop_sampling = 1;
        }
    }

    return polynomial, filled;
}

inline
fn sample_4_polynomials(
    reg ptr u8[32] rho,
    stack u16[4] domain_separators
) -> stack u32[COEFFICIENTS_IN_POLYNOMIAL],
     stack u32[COEFFICIENTS_IN_POLYNOMIAL],
     stack u32[COEFFICIENTS_IN_POLYNOMIAL],
     stack u32[COEFFICIENTS_IN_POLYNOMIAL]
{
    stack u256[25] xof_state;
    stack u8[SHAKE128_RATE] block0 block1 block2 block3;

    stack u32[COEFFICIENTS_IN_POLYNOMIAL] polynomial0 polynomial1 polynomial2 polynomial3;

    reg u64 filled0 filled1 filled2 filled3;
    reg u64 filled;

    reg u8 flg0 flg1 done_flag;
    reg bool cf zf, done;

    // Rejection sampling for the first time.
    // TODO: Use more than 1 block.
    xof_state = shake128_absorb4x_34(rho, domain_separators, xof_state);
    xof_state, block0, block1, block2, block3 = __shake128_squeezeblock4x(xof_state, block0, block1, block2, block3);

    polynomial0, filled = rejection_sample_init(polynomial0, block0);
    filled0 = filled;

    polynomial1, filled = rejection_sample_init(polynomial1, block1);
    filled1 = filled;

    polynomial2, filled = rejection_sample_init(polynomial2, block2);
    filled2 = filled;

    polynomial3, filled = rejection_sample_init(polynomial3, block3);
    filled3 = filled;

    _, cf, _, _, zf = #CMP_64(filled0, COEFFICIENTS_IN_POLYNOMIAL - 1);
    flg0 = #SETcc(cf || zf); //SETBE

    _, cf, _, _, zf = #CMP_64(filled1, COEFFICIENTS_IN_POLYNOMIAL - 1);
    flg1 = #SETcc(cf || zf);

    _, _, _, _, _, done_flag = #OR_8(flg0, flg1);

    _, cf, _, _, zf = #CMP_64(filled2, COEFFICIENTS_IN_POLYNOMIAL - 1);
    flg0 = #SETcc(cf || zf);

    _, cf, _, _, zf = #CMP_64(filled3, COEFFICIENTS_IN_POLYNOMIAL - 1);
    flg1 = #SETcc(cf || zf);

    _, _, _, _, _, flg0 = #OR_8(flg0, flg1);
    _, _, _, _, _, done_flag = #OR_8(flg0, done_flag);

    while{done = (done_flag == 0);}(!done) {
        xof_state, block0, block1, block2, block3 = __shake128_squeezeblock4x(xof_state, block0, block1, block2, block3);

        filled = filled0;
        polynomial0, filled = rejection_sample(polynomial0, filled, block0);
        filled0 = filled;

        filled = filled1;
        polynomial1, filled = rejection_sample(polynomial1, filled, block1);
        filled1 = filled;

        filled = filled2;
        polynomial2, filled = rejection_sample(polynomial2, filled, block2);
        filled2 = filled;

        filled = filled3;
        polynomial3, filled = rejection_sample(polynomial3, filled, block3);
        filled3 = filled;

        _, cf, _, _, zf = #CMP_64(filled0, COEFFICIENTS_IN_POLYNOMIAL - 1);
        flg0 = #SETcc(cf || zf); //SETBE

        _, cf, _, _, zf = #CMP_64(filled1, COEFFICIENTS_IN_POLYNOMIAL - 1);
        flg1 = #SETcc(cf || zf);

        _, _, _, _, _, done_flag = #OR_8(flg0, flg1);

        _, cf, _, _, zf = #CMP_64(filled2, COEFFICIENTS_IN_POLYNOMIAL - 1);
        flg0 = #SETcc(cf || zf);

        _, cf, _, _, zf = #CMP_64(filled3, COEFFICIENTS_IN_POLYNOMIAL - 1);
        flg1 = #SETcc(cf || zf);

        _, _, _, _, _, flg0 = #OR_8(flg0, flg1);
        _, _, _, _, _, done_flag = #OR_8(flg0, done_flag);
    }

    return polynomial0, polynomial1, polynomial2, polynomial3;
}
