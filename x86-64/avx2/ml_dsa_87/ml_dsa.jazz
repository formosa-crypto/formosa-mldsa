require "parameters.jinc"
require "encoding/error_polynomial.jinc"
require "encoding/gamma1.jinc"
require "arithmetic/rounding.jinc"

from Common require "arithmetic/rounding.jinc"
from Common require "arithmetic/modular.jinc"
from Common require "arithmetic/zetas.jinc"
from Common require "arithmetic/ntt.jinc"
from Common require "arithmetic/invert_ntt.jinc"

from Common require "keccak/keccak1600.jinc"
from Common require "keccak_avx2/keccakf1600_avx2.jinc"
from Common require "keccak_avx2/keccak1600_avx2.jinc"
from Common require "keccak_4x/api.jinc"
from Common require "hashing.jinc"
from Common require "hashing_4x.jinc"

from Common require "sample/matrix_A/matrix_A.jinc"
from Common require "sample/challenge.jinc"
from Common require "sample/mask/mask_1x.jinc"
from Common require "sample/mask/mask_4x.jinc"

from Common require "row_vector.jinc"
from Common require "column_vector.jinc"

from Common require "encoding/t0.jinc"
from Common require "encoding/t1.jinc"
from Common require "encoding/signature.jinc"
from Common require "encoding/s1.jinc"
from Common require "encoding/s2.jinc"

require "hashing.jinc"

from Common require "sample/error_vector_shuffles.jinc"
require "sample/error_vectors/4x.jinc"
require "sample/error_vectors.jinc"
require "sample/matrix_A.jinc"
from Common require "keygen.jinc"

require "sample/mask.jinc"
require "encoding/commitment.jinc"
from Common require "sign.jinc"

from Common require "verify.jinc"

// N.B.: If it seems that some functions seemingly lack annotations to guide the
// constant-time (CT) checker, it is because it looks for #[sct=...] annotations
// and ignores speculative-constant-time (SCT) related information; this is to say,
// the annotation given to the SCT checker can suffice for the CT checker as well.

// See api.h for the sizes of the buffers expected by these functions.

#[sct="{ptr: transient, val: transient} *
       {ptr: transient, val: secret} *
       {ptr: transient, val: secret} ->
       {ptr: transient, val: transient} *
       {ptr: secret, val: secret}"]
export fn ml_dsa_87_keygen(
    reg ptr u8[VERIFICATION_KEY_SIZE] verification_key,
    reg ptr u8[SIGNING_KEY_SIZE] signing_key,
    #spill_to_mmx reg ptr u8[32] randomness
) -> reg ptr u8[VERIFICATION_KEY_SIZE],
     reg ptr u8[SIGNING_KEY_SIZE]
{
    () = #spill(randomness);
    verification_key, signing_key = __keygen_internal(verification_key, signing_key, randomness);

    return verification_key, signing_key;
}

#[sct="{ptr: transient, val: transient} *
       {ptr: transient, val: secret} *
       transient * transient *
       {ptr: transient, val: secret} ->
       {ptr: transient, val: transient} * public"]
export fn ml_dsa_87_sign(
    #spill_to_mmx reg ptr u8[SIGNATURE_SIZE] signature,
    reg ptr u8[SIGNING_KEY_SIZE] signing_key,
    reg ptr u64[2] context_message_pointers,
    reg ptr u64[2] context_message_sizes,
    reg ptr u8[32] randomness
) -> reg ptr u8[SIGNATURE_SIZE], reg u64
{
    reg u64 result;
    reg u64 context_size = context_message_sizes[0];

    if (context_size <= 255) {
        signature = __sign_internal(signature, signing_key, context_message_pointers, context_message_sizes, randomness);
        result = 0;
    } else {
        result = -1;
    }

    return signature, result;
}

#[sct="{ptr: transient, val: transient} *
       transient * transient *
       {ptr: transient, val: transient} ->
       public"]
export fn ml_dsa_87_verify(
    #transient reg ptr u8[VERIFICATION_KEY_SIZE] verification_key,
    #transient reg ptr u64[2] context_message_pointers,
    #transient reg ptr u64[2] context_message_sizes,
    #transient reg ptr u8[SIGNATURE_SIZE] signature
) -> #public reg u64 {
    #public reg u64 verification_result;
    reg u64 context_size = context_message_sizes[0];

    if (context_size <= 255) {
        verification_result = __verify_internal(verification_key, context_message_pointers, context_message_sizes, signature);
    } else {
        verification_result = -1;
    }

    return verification_result;
}
