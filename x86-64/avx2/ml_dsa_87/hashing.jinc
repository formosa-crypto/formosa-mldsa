param int FULL_BLOCKS_IN_VERIFICATION_KEY = VERIFICATION_KEY_SIZE / SHAKE256_RATE;
fn hash_verification_key(
    #spill_to_mmx reg ptr u8[VERIFICATION_KEY_HASH_SIZE] verification_key_hash,
    #spill_to_mmx reg ptr u8[VERIFICATION_KEY_SIZE] verification_key
) -> reg ptr u8[VERIFICATION_KEY_HASH_SIZE]
{
    reg u256[7] state;
    #spill_to_mmx reg u64 verification_key_offset;

    reg u64 t64;
    reg u256 r0;
    reg u128 t128;

    // Absorb ...

    state = __state_init_avx2();

    // VERIFICATION_KEY_SIZE for ML-DSA-87 is:
    //
    // 2592 = SHAKE256_RATE * 19 + 8
    //
    verification_key_offset = 0;
    while(verification_key_offset < FULL_BLOCKS_IN_VERIFICATION_KEY * SHAKE256_RATE) {
        state = shake256_absorb_full_block(state, verification_key[verification_key_offset : SHAKE256_RATE]);
        verification_key_offset += SHAKE256_RATE;
    }

    // Now absorb the last partial block.
    reg ptr u8[8] block = verification_key[verification_key_offset:8];

    t64 = block.[:u64 0];
    t128 = (128u) t64;
    r0 = #VPBROADCAST_4u64(t128);
    state[0] ^= r0;

    // Finally, add the trail bit.
    t64 = 0x1f;
    r0 = (256u)#VMOV_64(t64);
    state[1] ^= r0;

    state = __addratebit_avx2(state, SHAKE256_RATE);

    // ... then squeeze.
    state = _keccakf1600_avx2(state);

    // VERIFICATION_KEY_HASH_SIZE is always 64.
    verification_key_hash = stream_64_bytes(verification_key_hash, state);

    return verification_key_hash;
}
