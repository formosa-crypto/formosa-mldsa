param int FULL_BLOCKS_IN_VERIFICATION_KEY = VERIFICATION_KEY_SIZE / SHAKE256_RATE;
fn hash_verification_key(
    #spill_to_mmx reg ptr u8[VERIFICATION_KEY_HASH_SIZE] verification_key_hash,
    #spill_to_mmx reg ptr u8[VERIFICATION_KEY_SIZE] verification_key
) -> reg ptr u8[VERIFICATION_KEY_HASH_SIZE]
{
    reg u256[7] state;
    #spill_to_mmx reg u64 verification_key_offset;

    reg u64 t64;
    reg u256 r0, r1, r2;
    reg u128 t128_0, t128_1;

    // Absorb ...

    state = __state_init_avx2();

    // N.B.: The VERIFICATION_KEY_SIZE for ML-DSA-65 is:
    //
    // 1952 = SHAKE256_RATE * 14 + 48
    //
    verification_key_offset = 0;
    while(verification_key_offset < FULL_BLOCKS_IN_VERIFICATION_KEY * SHAKE256_RATE) {
        state = shake256_absorb_full_block(state, verification_key[verification_key_offset : SHAKE256_RATE]);
        verification_key_offset += SHAKE256_RATE;
    }

    // Now absorb the last 48-byte block.
    reg ptr u8[48] block = verification_key[verification_key_offset:48];

    t64 = block.[:u64 0];
    t128_0 = (128u) t64;
    r0 = #VPBROADCAST_4u64(t128_0);
    state[0] ^= r0;

    r1 = block.[:u256 8];
    state[1] ^= r1;

    t64 = block.[:u64 40];
    t128_1 = (128u) t64;

    t128_0 = #set0_128();

    t64 = 0;
    t128_1 = #VPINSR_2u64(t128_1, t64, 1);

    r2 = (2u128)[t128_1, t128_0];
    state[2] ^= r2;

    // Finally, add the trail bit.
    t64 = 0x1f;
    r2 = (256u)#VMOV_64(t64);
    state[6] ^= r2;

    state = __addratebit_avx2(state, SHAKE256_RATE);

    // ... then squeeze.
    state = _keccakf1600_avx2(state);

    // VERIFICATION_KEY_HASH_SIZE is always 64.
    verification_key_hash = stream_64_bytes(verification_key_hash, state);

    return verification_key_hash;
}
